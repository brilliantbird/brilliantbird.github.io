<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2023/07/07/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>Markdown</title>
    <url>/2023/07/14/Markdown/</url>
    <content><![CDATA[<h1 id="一、Markdown简介"><a href="#一、Markdown简介" class="headerlink" title="一、Markdown简介"></a>一、Markdown简介</h1><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p>
<p>Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。</p>
<p>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。</p>
<p>Markdown 编写的文档后缀为 .md, .markdown。</p>
<p>Markdown 能被使用来撰写电子书，如：Gitbook。</p>
<p>当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge等。</p>
<h1 id="二、Markdown标题"><a href="#二、Markdown标题" class="headerlink" title="二、Markdown标题"></a>二、Markdown标题</h1><p>使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。<br><strong>注意：#后面一定要跟着空格，否则语法无效！</strong></p>
<p>标题内容的后面如果也存在空格和 #，也可以构成标题，且标题的级别以前面 # 的数量为准。</p>
<p><strong>使用#号标记标题语法格式：</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line"></span><br><span class="line">## 二级标题</span><br><span class="line"></span><br><span class="line">### 三级标题</span><br><span class="line"></span><br><span class="line">#### 四级标题</span><br><span class="line"></span><br><span class="line">##### 五级标题</span><br><span class="line"></span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure></div>
<p>显示效果：<br>[TOC]目录</p>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h1 id="三、Markdown段落"><a href="#三、Markdown段落" class="headerlink" title="三、Markdown段落"></a>三、Markdown段落</h1><p>Markdown的段落没有特殊的格式，直接编写文字就好，段落的换行号是使用两个以上的空格加回车。</p>
<h2 id="3-1字体"><a href="#3-1字体" class="headerlink" title="3.1字体"></a>3.1字体</h2><p>Markdown 可以使用以下几种字体：</p>
<ul>
<li>用1个星号*或底线_表示斜体</li>
<li>用2个星号*或底线_表示粗体</li>
<li>用3个星号*或底线_表示粗斜体</li>
</ul>
<p>语法格式：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">*斜体文字*</span><br><span class="line"></span><br><span class="line">_斜体文字_</span><br><span class="line"></span><br><span class="line">**粗体文字**</span><br><span class="line"></span><br><span class="line">__粗体文字__</span><br><span class="line"></span><br><span class="line">***粗斜体文字***</span><br><span class="line"></span><br><span class="line">___粗斜体文字___</span><br></pre></td></tr></table></figure></div>

<p>显示效果：</p>
<p><em>斜体文字</em></p>
<p><em>斜体文字</em></p>
<p><strong>粗体文字</strong></p>
<p><strong>粗体文字</strong></p>
<p><em><strong>粗斜体文字</strong></em></p>
<p><em><strong>粗斜体文字</strong></em></p>
<h2 id="3-2分隔线"><a href="#3-2分隔线" class="headerlink" title="3.2分隔线"></a>3.2分隔线</h2><p>可以在一行中用三个以上的星号*、减号-、底线_来建立一个分隔线，行内不能有其他东西，你也可以在星号或减号蹭插入空格。下面这种写法都可以建立分隔线：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">***</span><br><span class="line">* * *</span><br><span class="line">******</span><br><span class="line">- - -</span><br><span class="line">------</span><br></pre></td></tr></table></figure></div>

<h2 id="显示效果："><a href="#显示效果：" class="headerlink" title="显示效果：**** * *******- - -"></a>显示效果：<br>***<br>* * *<br>******<br>- - -</h2><h2 id="3-3删除线"><a href="#3-3删除线" class="headerlink" title="3.3删除线"></a>3.3删除线</h2><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线~~即可。</p>
<p>语法格式：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">~~要显示为要删除线的字~~</span><br></pre></td></tr></table></figure></div>

<p>显示效果：</p>
<p><del>要显示为要删除线的字</del></p>
<h2 id="3-4下划线"><a href="#3-4下划线" class="headerlink" title="3.4下划线"></a>3.4下划线</h2><p>下划线可以通过HTML的标签来实现</p>
<p>语法格式：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;u&gt;带下划线文本&lt;/u&gt;</span><br></pre></td></tr></table></figure></div>

<p>显示效果：</p>
<p><u>带下划线文本</u></p>
<h1 id="四、Markdown列表"><a href="#四、Markdown列表" class="headerlink" title="四、Markdown列表"></a>四、Markdown列表</h1><h2 id="4-1有序列表和无序列表"><a href="#4-1有序列表和无序列表" class="headerlink" title="4.1有序列表和无序列表"></a>4.1有序列表和无序列表</h2><p>Markdown支持有序列表和无序列表，</p>
<p>无序列表使用星号(*)、加号(+)或者减号(-)作为标记：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 第一项</span><br><span class="line">* 第二项</span><br><span class="line">* 第三项</span><br><span class="line"></span><br><span class="line">+ 第一项</span><br><span class="line">+ 第二项</span><br><span class="line">+ 第三项</span><br><span class="line"></span><br><span class="line">- 第一项</span><br><span class="line">- 第二项</span><br><span class="line">- 第三项</span><br></pre></td></tr></table></figure></div>

<p>显示效果：</p>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<p>有序列表直接在文字有加上1. 2. 3. 来表示，符号和文字之间加上一个空格字符，如：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 第一项</span><br><span class="line">2. 第二项</span><br><span class="line">3. 第三项</span><br></pre></td></tr></table></figure></div>

<p>显示效果：</p>
<ol>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ol>
<h2 id="4-2列表嵌套"><a href="#4-2列表嵌套" class="headerlink" title="4.2列表嵌套"></a>4.2列表嵌套</h2><p>列表嵌套只需在子列表的选项前添加四个空格即可：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 第一项：</span><br><span class="line">    - 第一项嵌套的第一个元素</span><br><span class="line">    - 第一项嵌套的第二个元素</span><br><span class="line">2. 第二项：</span><br><span class="line">    - 第二项嵌套的第一个元素</span><br><span class="line">    - 第二项嵌套的第二个元素</span><br></pre></td></tr></table></figure></div>

<p>显示效果：</p>
<ol>
<li>第一项：<ul>
<li>第一项嵌套的第一个元素</li>
<li>第一项嵌套的第二个元素</li>
</ul>
</li>
<li>第二项：<ul>
<li>第二项嵌套的第一个元素</li>
<li>第二项嵌套的第二个元素</li>
</ul>
</li>
</ol>
<h1 id="五、引用"><a href="#五、引用" class="headerlink" title="五、引用"></a>五、引用</h1><p>Markdown区块引用是在段落开头使用&gt;符号，然后后面紧跟一个空格符号：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; 区块引用  </span><br><span class="line">&gt; Markdown教程  </span><br><span class="line">&gt; 学的不仅是技术更是梦想</span><br></pre></td></tr></table></figure></div>

<p>显示效果：</p>
<blockquote>
<p>区块引用<br>Markdown教程<br>学的不仅是技术更是梦想  </p>
</blockquote>
<p>另外区块是可以嵌套的，一个&gt;符号是最外层，两个符号是第一层嵌套，以此类推：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; 最外层</span><br><span class="line">&gt;&gt; 第一层嵌套</span><br><span class="line">&gt;&gt;&gt; 第二层嵌套</span><br></pre></td></tr></table></figure></div>

<p>显示效果：</p>
<blockquote>
<p>最外层</p>
<blockquote>
<p>第一层嵌套</p>
<blockquote>
<p>第二层嵌套</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="5-1区块引用中使用列表"><a href="#5-1区块引用中使用列表" class="headerlink" title="5.1区块引用中使用列表"></a>5.1区块引用中使用列表</h2><p>区块中使用列表实例如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; 区块中使用列表</span><br><span class="line">&gt; 1. 第一项</span><br><span class="line">&gt; 2. 第二项</span><br><span class="line">&gt; + 第一项</span><br><span class="line">&gt; + 第二项</span><br><span class="line">&gt; + 第三项</span><br></pre></td></tr></table></figure></div>

<p>显示效果：</p>
<blockquote>
<p>区块中使用列表</p>
<ol>
<li>第一项</li>
<li>第二项</li>
</ol>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
</blockquote>
<h2 id="5-2引用多个段落"><a href="#5-2引用多个段落" class="headerlink" title="5.2引用多个段落"></a>5.2引用多个段落</h2><p>引用可以包含多个段落，引用内段落和普通段落一样，不过在空行前面也要加上小于号。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; 这是一个引用段落</span><br><span class="line">&gt;</span><br><span class="line">&gt; 这是另一个引用段落</span><br></pre></td></tr></table></figure></div>

<p>显示效果：</p>
<blockquote>
<p>这是一个引用段落</p>
<p>这是另一个引用段落</p>
</blockquote>
<h1 id="六、Markdown代码块"><a href="#六、Markdown代码块" class="headerlink" title="六、Markdown代码块"></a>六、Markdown代码块</h1><h2 id="6-1行内代码"><a href="#6-1行内代码" class="headerlink" title="6.1行内代码"></a>6.1行内代码</h2><p>使用一对反引号(&#96;)来创建行内代码。如果在行内代码中需要包含反引号本身，可以使用两个反引号对加前后空格来创建。</p>
<h2 id="6-2代码块！"><a href="#6-2代码块！" class="headerlink" title="6.2代码块！"></a>6.2代码块！</h2><p>将文本的每一行缩进至少四个空格或一个制表符。这样这些文本会变成代码块。</p>
<h2 id="6-3围栏式代码块！"><a href="#6-3围栏式代码块！" class="headerlink" title="6.3围栏式代码块！"></a>6.3围栏式代码块！</h2><p>在很多 Markdown 解析器里都支持使用三个反引号(&#96;)或三个波浪号(~)来定义围栏式代码块。同时这种代码块配合插件还可以做到代码高亮、行号等高级功能。（如果在代码块中也存在三个反引号或波浪号，可以在外层使用 4 个。）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">```javascript</span><br><span class="line">const a = 1;</span><br><span class="line">const b = 2;</span><br><span class="line">function add(num1, num2) &#123;</span><br><span class="line">  return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">console.log(add(a, b));</span><br><span class="line">```</span><br></pre></td></tr></table></figure></div>

<p>显示效果：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(a, b));</span><br></pre></td></tr></table></figure></div>

<h1 id="七、Markdown链接"><a href="#七、Markdown链接" class="headerlink" title="七、Markdown链接"></a>七、Markdown链接</h1><h2 id="7-1链接到网站"><a href="#7-1链接到网站" class="headerlink" title="7.1链接到网站"></a>7.1链接到网站</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[茄迷的bolg](https://brilliantbird.github.io/)</span><br></pre></td></tr></table></figure></div>

<p>显示效果：</p>
<p><a class="link"   href="https://brilliantbird.github.io/" >茄迷的bolg <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="7-2高级链接"><a href="#7-2高级链接" class="headerlink" title="7.2高级链接"></a>7.2高级链接</h2><p>链接也可以用变量来代替，文档末尾附带变量地址：<br>这个链接用1作为网址变量<a class="link"   href="http://www.baidu.com/" >baidu <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>这个链接用markdown作为网址变量<a class="link"   href="http://www.markdown.com/" >Markdown <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>然后文档的结尾为变量赋值(网址)</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1]: http://www.baidu.com</span><br><span class="line">[markdown]: http://www.markdown.com</span><br></pre></td></tr></table></figure></div>
<p>显示效果：(我在写笔记的时候加了两句，但是这里并没有没有显示出来。加了两句超链接以后，baidu和Markdown就可以变成超链接点进去了)</p>
<h1 id="八、Markdown图片"><a href="#八、Markdown图片" class="headerlink" title="八、Markdown图片"></a>八、Markdown图片</h1><p>Markdown图片语法格式为：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">![alt 属性文本](图片地址)</span><br><span class="line">![alt 属性文本](图片地址 &quot;可选标题&quot;)</span><br></pre></td></tr></table></figure></div>

<ul>
<li>开头一个感叹号!</li>
<li>接着一个方括号，里面放上图片的代替文字</li>
<li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的’title’属性文字。</li>
</ul>
<p>举个例子：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">![帅哥照片](https://bkimg.cdn.bcebos.com/pic/b17eca8065380cd79123caf75208ba345982b2b72bde?x-bce-process=image/resize,m_lfit,h_4096,limit_1/watermark,image_d2F0ZXIvYmFpa2UyNzI=,g_7,xp_5,yp_5/format,f_auto)</span><br></pre></td></tr></table></figure></div>

<p><strong>1. 补充：带链接的图片</strong></p>
<p>下面的代码，把生成图片的代码放到了超链接的名称里面。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[![这是一个图片](/images/tutorials/markdown/工具页截图-dark.png)](/tools/)</span><br></pre></td></tr></table></figure></div>

<p><strong>2. 补充：带title的图片</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">![这是一个图片](/images/tutorials/markdown/工具页截图-dark.png &quot;这是工具页的截图&quot;)</span><br></pre></td></tr></table></figure></div>

<h1 id="九、Emoji表情"><a href="#九、Emoji表情" class="headerlink" title="九、Emoji表情"></a>九、Emoji表情</h1><p>在 Markdown 里使用 Emoji 表情有两种方法，一种是直接输入 Emoji 表情，另一种是使用 Emoji 表情短码(emoji shartcodes)。</p>
<p>Emoji 表情短码放到两个冒号(:)之间，比如： :joy:😂。</p>
<h1 id="十、表格"><a href="#十、表格" class="headerlink" title="十、表格"></a>十、表格</h1><p>表格使用竖线(|)区分每一列，在表格头和表格体之间第列使用至少三个减号(-)来做为分隔。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">|第一列|第二列|第三列|</span><br><span class="line">|---|---|---|</span><br><span class="line">|第一行第一列|第一行第二列|第一行第三列|</span><br><span class="line">|第二行第一列|第二行第二列|第二行第三列|</span><br></pre></td></tr></table></figure></div>

<p>显示效果：</p>
<table>
<thead>
<tr>
<th>第一列</th>
<th>第二列</th>
<th>第三列</th>
</tr>
</thead>
<tbody><tr>
<td>第一行第一列</td>
<td>第一行第二列</td>
<td>第一行第三列</td>
</tr>
<tr>
<td>第二行第一列</td>
<td>第二行第二列</td>
<td>第二行第三列</td>
</tr>
</tbody></table>
<p><strong>补充：设置表格的对齐方式</strong></p>
<p>下列代码，在第二行的每一列都添加了冒号(:)，左侧添加一个冒号表示该列左对齐，右侧添加一个冒号表示该列右对齐，左右各添加一个冒号表示该列居中对齐。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">|第一列|第二列|第三列|</span><br><span class="line">|:---|:---:|---:|</span><br><span class="line">|这一列是左对齐的|这一列是居中对齐的|这一列是右对齐的|</span><br></pre></td></tr></table></figure></div>

<p>显示效果：</p>
<table>
<thead>
<tr>
<th align="left">第一列</th>
<th align="center">第二列</th>
<th align="right">第三列</th>
</tr>
</thead>
<tbody><tr>
<td align="left">这一列是左对齐的</td>
<td align="center">这一列是居中对齐的</td>
<td align="right">这一列是右对齐的</td>
</tr>
</tbody></table>
<p>在表格中可以使用斜体单行元素，比如粗体斜体、行内代码、超链接、图片、Emoji表情、HTML等。</p>
<p>关于图表，公式，脚注，注释，内嵌HTML和React的相关内容未完待续！！！</p>
]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>判断语句</title>
    <url>/2023/07/15/%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h1 id="一、bool类型和比较运算符"><a href="#一、bool类型和比较运算符" class="headerlink" title="一、bool类型和比较运算符"></a>一、bool类型和比较运算符</h1><p>bool类型的本质还是数字类型，True的底层就是1，False底层就是0。</p>
<p>bool类型的数据不仅可以通过定义得到，也可以通过比较运算符（&#x3D;&#x3D;、&gt;、&lt;、!&#x3D;、&gt;&#x3D;、&lt;&#x3D;）进行内容比较得到。  </p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">bool_1 = Ture</span><br><span class="line">bool_2 = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">bool_3 = <span class="number">5</span>&gt;<span class="number">3</span></span><br><span class="line">bool_4 = <span class="number">1</span>&gt;<span class="number">6</span></span><br><span class="line">bool_5 = <span class="number">1</span> ==<span class="number">1</span></span><br></pre></td></tr></table></figure></div>

<h1 id="二、if语句的基本格式"><a href="#二、if语句的基本格式" class="headerlink" title="二、if语句的基本格式"></a>二、if语句的基本格式</h1><h2 id="2-1-if基本格式"><a href="#2-1-if基本格式" class="headerlink" title="2.1 if基本格式"></a>2.1 if基本格式</h2><p>语法格式：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 要判断的条件：</span><br><span class="line">    条件成立时要执行的语句</span><br></pre></td></tr></table></figure></div>
<p>细节：  </p>
<ul>
<li>冒号别少了</li>
<li>与c语言用大括号来判断归属关系不同的是Python是通过空格缩进来判断归属关系的！（四个空格缩进）</li>
<li>判断语句的结果必须是bool类型的True和False</li>
</ul>
<h2 id="2-2-if-else语句"><a href="#2-2-if-else语句" class="headerlink" title="2.2 if else语句"></a>2.2 if else语句</h2><p>语法格式：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">if 条件:</span><br><span class="line">    条件成立时要执行的语句</span><br><span class="line">else:</span><br><span class="line">    不满足的时候执行的语句</span><br></pre></td></tr></table></figure></div>

<p>注意 ：</p>
<ul>
<li>else不需要判断条件</li>
<li>else同样需要四个空格进行缩进</li>
</ul>
<h2 id="2-3-if-elif-else语句进行多条件判断的语法"><a href="#2-3-if-elif-else语句进行多条件判断的语法" class="headerlink" title="2.3 if elif else语句进行多条件判断的语法"></a>2.3 if elif else语句进行<strong>多条件判断</strong>的语法</h2><p>语法格式：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件<span class="number">1</span>：</span><br><span class="line">    ......</span><br><span class="line"><span class="keyword">elif</span> 条件<span class="number">2</span>：</span><br><span class="line">    ......</span><br><span class="line"><span class="keyword">elif</span> 条件<span class="number">3</span>：</span><br><span class="line">    ......</span><br><span class="line"><span class="keyword">else</span>：</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure></div>

<p><strong>可以实现多条件判断！！！先判断条件1满足不满足，然后再依次判断条件2，条件3……如果全部不满足就执行else</strong></p>
<p>注意：</p>
<ul>
<li>判断是互斥且<strong>有顺序的</strong></li>
<li>满足其中一个条件，执行完相关的语句以后就会跳出这个层次的if语句。</li>
<li>else可以不写</li>
<li>空格缩进同样不可省略</li>
</ul>
<p>举个例子：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">num == <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请猜一个数字： &quot;</span>)) == num：</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;猜对了&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;猜错了，再猜一个数字： &quot;</span>)) == num：</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;猜对了&quot;</span>)</span><br><span class="line"><span class="keyword">else</span> ：</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;猜错了&quot;</span>)</span><br></pre></td></tr></table></figure></div>
<p>这个例子告诉我们，if elif else是按顺序从上往下一个个执行的，其次可以在if的条件里面去写input函数，这样子代码更加简洁。别忘了把输入的数据转换成int类型后再进行比较！</p>
<h2 id="2-4判断语句的嵌套"><a href="#2-4判断语句的嵌套" class="headerlink" title="2.4判断语句的嵌套"></a>2.4判断语句的嵌套</h2><p>由于许多的逻辑的判断是嵌套的，多层次的。对于这种需求，我们可以自由组合if elif else ，完成特定需求的要求。</p>
<p>语法格式：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件<span class="number">1</span>：</span><br><span class="line">    …………</span><br><span class="line">    <span class="keyword">if</span> 条件<span class="number">2</span>：</span><br><span class="line">        …………</span><br><span class="line">        …………</span><br></pre></td></tr></table></figure></div>
<p>可以看到，只有条件1满足以后才会去判断条件2是否满足。<br>嵌套的关键在于<strong>空格缩进！！！</strong><br>还是记住：通过空格缩进来决定语句之间的：<strong>层次关系</strong></p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>函数</title>
    <url>/2023/07/16/%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>特点：</p>
<ul>
<li>已经组织好的</li>
<li>可重复使用</li>
<li>针对特定功能</li>
</ul>
<p>使用函数可以：得到一个针对特定需求、可供重复利用的代码段。提供程序的复用性、减少重复性代码，提高开发效率。  </p>
<h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><p>函数定义语法格式：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">函数名</span>(<span class="params">传入参数</span>):</span><br><span class="line">    函数体</span><br><span class="line">    <span class="keyword">return</span> 返回值</span><br></pre></td></tr></table></figure></div>

<p>函数调用：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数名(参数)</span><br></pre></td></tr></table></figure></div>
<p>注意：</p>
<ul>
<li>参数和返回值都可以省略</li>
<li>函数必须先定义后使用</li>
</ul>
<h2 id="函数的传入参数"><a href="#函数的传入参数" class="headerlink" title="函数的传入参数"></a>函数的传入参数</h2><p>示例：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x,y</span>)</span><br><span class="line">    result = x + y</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></div>
<ul>
<li>x,y称为形式参数，表示函数就要使用这两个参数。</li>
<li><strong>c参数之间用逗号分隔</strong></li>
<li>函数调用中，提供的参数称之为实际参数，表示函数执行的时候真正使用的参数值。</li>
<li>传入实际参数的时候，按照顺序传入数据，使用逗号分隔。</li>
<li>传入参数的个数是不受限制的，可以不使用参数，也可以仅使用任意的N个参数。</li>
</ul>
<h2 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h2><p><strong>通过return关键字将函数执行结果返回给函数的调用者。</strong></p>
<p>函数体遇到return以后就结束了，所以写在return后面的代码就不会执行了。</p>
<h2 id="None类型"><a href="#None类型" class="headerlink" title="None类型"></a>None类型</h2><p>如果函数没有使用return语句返回数据，函数也是有返回值的。Python中有一个特殊的字面量：None，类型是：&lt;class‘NoneType’&gt;，无返回值的函数，实际上就是返回了：None这个字面量。表示函数没有返回什么有意义的内容，也就是返回了空的意思。</p>
<p>应用场景：</p>
<ol>
<li><p>用在函数无返回值上</p>
</li>
<li><p>用在if判断中</p>
<ul>
<li>在if判断中，None等同于False</li>
<li>一般在函数中主动返回None，配合if判断做相关处理。</li>
</ul>
</li>
<li><p>用于声明无内容的变量上</p>
<ul>
<li>定义变量，但暂时不需要变量有具体值，可以用None来代替</li>
</ul>
</li>
</ol>
<h2 id="函数说明文档"><a href="#函数说明文档" class="headerlink" title="函数说明文档"></a>函数说明文档</h2><p>我们通过给函数添加说明文档，辅助理解函数的作用。</p>
<p>通过多行注释的形式，对函数进行说明解释。</p>
<ul>
<li>内容应写在函数体之前。</li>
</ul>
<p>建议的语法格式：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">x,y</span>)</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    函数说明</span></span><br><span class="line"><span class="string">    ：param x：形参x的说明</span></span><br><span class="line"><span class="string">    ：param y：形参y的说明</span></span><br><span class="line"><span class="string">    ：return： 返回值的说明</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>PyCharm会自动补全</li>
<li>在PyCharm编写代码的时候，通过鼠标悬停，可以查看调用函数的说明文档</li>
</ul>
<h2 id="函数的嵌套调用"><a href="#函数的嵌套调用" class="headerlink" title="函数的嵌套调用"></a>函数的嵌套调用</h2><p>定义： 在一个函数里面又调用另外一个函数。</p>
<ul>
<li>在函数A中，调用另外一个函数B，那么先把函数B的任务都执行完才会回到上次函数A执行的位置，继续往下面执行。</li>
</ul>
<h2 id="函数中的变量作用域"><a href="#函数中的变量作用域" class="headerlink" title="函数中的变量作用域"></a>函数中的变量作用域</h2><p>变量作用域指的是变量的作用范围（变量在哪里可用，在哪里不可用）<br>主要分为俩类：<strong>局部变量和全局变量</strong></p>
<p><strong>局部变量：定义在函数体内部的变量，就只能在函数体内部生效。</strong></p>
<p><strong>全局变量：在函数体内部和外部都可以生效的变量</strong></p>
<h3 id="global关键字"><a href="#global关键字" class="headerlink" title="global关键字"></a>global关键字</h3><p>如果在函数内部修改全局变量的值，那么该全局变量在这个函数内还是按照修改后的值允许，但是在函数的外面，该全局变量的值其实并没有发送改变。也就是说，该全局变量在函数体内部还是被看做是一个局部变量了，和外面的全局变量没有一点关系。</p>
<p>那么，我们就是想在函数内部将全局变量的值修改，要怎么办呢？</p>
<p>使用global关键字。</p>
<p>在函数体内通过global声明变量，以代表该变量是一个全局变量。</p>
<p><strong>总结：global关键字可以让在函数内定义的变量变成全局变量。</strong></p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>循环结构</title>
    <url>/2023/07/15/%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h1><h2 id="1-1while循环的基础使用"><a href="#1-1while循环的基础使用" class="headerlink" title="1.1while循环的基础使用"></a>1.1while循环的基础使用</h2><p>语法格式：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件：</span><br><span class="line">    条件满足时执行的语句……</span><br></pre></td></tr></table></figure></div>
<p><strong>只要条件（可以是bool或者比较运算）满足，就会无限循环执行</strong></p>
<h2 id="1-2while的嵌套循环"><a href="#1-2while的嵌套循环" class="headerlink" title="1.2while的嵌套循环"></a>1.2while的嵌套循环</h2><p>和if的嵌套几乎一模一样，只需要把if的嵌套中的if改成while就是while的嵌套循环了。</p>
<p><strong>注意：此处的嵌套循环同样是基于空格缩进来决定层次关系。</strong></p>
<hr>
<p>补充内容：</p>
<ol>
<li>默认print语句输出内容会自动换行，所以有时候也会用print语句输出空内容来实现换行。（与c语言不同）</li>
</ol>
<p>如果想要使用print语句，输出不换行的功能的话，需要这么写：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;World&quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure></div>
<ol start="2">
<li>制表符\t<br>效果等同于tab键，可以让多行字符串进行对齐。</li>
</ol>
<h2 id="示例：如此输出以后，上下俩行的上下两个字符串就会对齐！"><a href="#示例：如此输出以后，上下俩行的上下两个字符串就会对齐！" class="headerlink" title="示例：如此输出以后，上下俩行的上下两个字符串就会对齐！"></a>示例：<br><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(&quot;Hello\tWorld&quot;)</span><br><span class="line">print(&quot;qiemi\t666&quot;)</span><br></pre></td></tr></table></figure></div><br>如此输出以后，上下俩行的上下两个字符串就会对齐！</h2><h2 id="2-1-for循环基础语法"><a href="#2-1-for循环基础语法" class="headerlink" title="2.1 for循环基础语法"></a>2.1 for循环基础语法</h2><p>与while循环的区别：</p>
<ul>
<li>while循环的循环条件是自定义的，<strong>自行控制循环条件</strong></li>
<li>for循环是一种<strong>“轮询”</strong>机制，是对一批内容进行“逐个处理”</li>
</ul>
<p>语法格式：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 临时变量 <span class="keyword">in</span> 待处理数据集（序列):</span><br><span class="line">    循环满足条件时执行的代码</span><br></pre></td></tr></table></figure></div>

<ul>
<li>in是一个关键字</li>
<li>执行逻辑是从待处理数据集中的数据逐个取出，每个循环就将当前输出赋予这个临时变量，然后执行循环体内的代码。</li>
</ul>
<p>举个例子：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;cheming&quot;</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> name:</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>for循环是无法定义循环条件的，只呢从数据集里面依次取出内容进行处理，理论上来说Python的for循环无法构建无限循环。</p>
</li>
<li><p>同样有空格缩进</p>
</li>
</ul>
<h2 id="2-2-range语句"><a href="#2-2-range语句" class="headerlink" title="2.2 range语句"></a>2.2 range语句</h2><p>待处理数据集的严格说法叫做：序列类型。<br>序列类型指：内容可以一个个依次取出的一种类型。包括：</p>
<ul>
<li>字符串</li>
<li>列表</li>
<li>元组</li>
<li>等</li>
</ul>
<p>因此for循环语句，本质上是遍历：序列类型。</p>
<p>学习range语句，获得一个简单的数字序列：</p>
<p>语法1：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">range</span>(num)</span><br></pre></td></tr></table></figure></div>
<p>可以获取一个从0开始，到num结束的数字序列（不含num本身）</p>
<p>比如range（5）取得的数据是： [0,1,2,3,4,]</p>
<p>语法2：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">range</span>(num1,num2)</span><br></pre></td></tr></table></figure></div>
<p>获得一个从num1开始，到num2结束的数字序列（不包含num2本身）</p>
<p>语法3：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">range</span>(num1,num2,step)</span><br></pre></td></tr></table></figure></div>

<p>获得一个从num1开始，到num2结束的数字序列（不包含num2本身），并且数字之间的步长以step为准。（step默认是1）</p>
<p>大多数的range序列都是配合for循环使用的</p>
<h2 id="2-3-变量作用域"><a href="#2-3-变量作用域" class="headerlink" title="2.3 变量作用域"></a>2.3 变量作用域</h2><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure></div>
<p>这样子的写法：</p>
<ul>
<li>规范上：不允许</li>
<li>实际上：允许</li>
</ul>
<p>for循环创建的临时变量的作用范围只在for循环的内部， <strong>也就是作用域就在循环体内</strong>，不应该在for循环外部生效（不是不可能）。实际上是可以访问到的，但是在编程的规范上是不允许、不建议这么做。可以在for循环之前就定义好i。</p>
<h2 id="2-4-for循环的嵌套"><a href="#2-4-for循环的嵌套" class="headerlink" title="2.4 for循环的嵌套"></a>2.4 for循环的嵌套</h2><p>语法格式和while嵌套循环一样的。</p>
<p>关键点就是注意好<strong>空格缩进</strong>就行了</p>
<h2 id="3-break和continue关键字"><a href="#3-break和continue关键字" class="headerlink" title="3. break和continue关键字"></a>3. break和continue关键字</h2><p><strong>这两个关键字的用法和c语言中一样</strong></p>
<p>continue：中断本次循环，直接进入下一次循环。可用于for和while循环，效果一致。</p>
<p>注意：</p>
<ul>
<li>如果是在嵌套循环中，continue只能在它所在的循环临时中断。也就是只会中断内部循环，而不会中断外部循环。</li>
</ul>
<p>break： 直接结束循环，可用于for和while循环，效果一致。<br>注意：</p>
<ul>
<li>在嵌套循环中的用法与continue一样。</li>
</ul>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>数据容器</title>
    <url>/2023/07/16/%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="数据容器"><a href="#数据容器" class="headerlink" title="数据容器"></a>数据容器</h1><h2 id="1-数据容器是什么？"><a href="#1-数据容器是什么？" class="headerlink" title="1. 数据容器是什么？"></a>1. 数据容器是什么？</h2><p>程序中如果要记录多个信息，如果一个个去定义变量会非常麻烦。数据容器就是用一个变量，记录多份数据。也就是可以批量存储和批量使用多份数据，类似于数组！</p>
<ul>
<li><p>Python中的数据容器：一种可以<strong>容纳多份数据</strong>的数据类型，容纳的每一份数据称之为一个元素，每一个元素可以是任意类型的数据，比如字符串，数字，bool等等。</p>
</li>
<li><p>数据容器根据特点的不同，比如：</p>
<ul>
<li>是否支持重复元素</li>
<li>是否可以修改</li>
<li>是否有序</li>
<li>等等</li>
</ul>
</li>
</ul>
<p>可以分为五类：列表（list）、元组（tuple）、字符串（str）、集合（set）、字典（dict）。</p>
<h2 id="2-list（列表）"><a href="#2-list（列表）" class="headerlink" title="2. list（列表）"></a>2. list（列表）</h2><h3 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h3><p>基本语法：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#字面量</span></span><br><span class="line">[元素<span class="number">1</span>，元素<span class="number">2</span>，元素<span class="number">3</span>，……]</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义变量</span></span><br><span class="line">变量名称 = [元素<span class="number">1</span>，元素<span class="number">2</span>，元素<span class="number">3</span>，……]</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义空列表</span></span><br><span class="line">变量名称 = []</span><br><span class="line">变量名称 = <span class="built_in">list</span>()</span><br></pre></td></tr></table></figure></div>

<ul>
<li>列表中的每一个数据，称之为元素。元素类型可以为不同的数据类型，而且支持嵌套。</li>
<li>以[]作为标识。</li>
<li>列表内每一个元素之间用逗号隔开。</li>
</ul>
<h3 id="2-2列表的下标索引"><a href="#2-2列表的下标索引" class="headerlink" title="2.2列表的下标索引"></a>2.2列表的下标索引</h3><p>通过下标索引取出列表里面特定位置的数据。</p>
<p>语法：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">列表[下标索引]</span><br></pre></td></tr></table></figure></div>
<p>与c语言不同，列表的下标可以反向索引。比如最后一个元素的下标标记为-1，倒数第二的下标就是-2，以此类推。（就是你直接引用下标是-1的元素，结果就是最后一个元素。）</p>
<p>总之就是说，想取第一个元素，下标就给0，想取最后一个元素，如果在c语言不知道数组长度的话很麻烦，但是Python里面直接下标是-1取出来就是最后一个元素。</p>
<p>列表嵌套的下标索引：</p>
<p>举个例子：</p>
<p>列表[1][0]</p>
<p>意思就是指有一个列表，第二个元素也是列表，先取出这个列表的第二个元素也就是嵌套的列表，然后再取这个内层列表的第一个元素。写法类似于二维数组，但是含义是不一样的。</p>
<ul>
<li>如果下标超出列表本身的大小范围就会报错。</li>
</ul>
<h3 id="2-3列表的常用操作方式"><a href="#2-3列表的常用操作方式" class="headerlink" title="2.3列表的常用操作方式"></a>2.3列表的常用操作方式</h3><p><strong>列表的方法（写在类（class）里面的函数就是方法）</strong>：</p>
<ol>
<li>插入元素</li>
<li>删除元素</li>
<li>清空列表</li>
<li>修改元素</li>
<li>统计元素个数</li>
</ol>
<h4 id="列表的查询功能（方法）"><a href="#列表的查询功能（方法）" class="headerlink" title="列表的查询功能（方法）"></a>列表的查询功能（方法）</h4><ul>
<li>查找某个元素的下标。</li>
</ul>
<p>功能：查找指定元素在列表的下标，如果找不到，报错<strong>ValueError</strong></p>
<p>语法：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">列表.index（元素）</span><br></pre></td></tr></table></figure></div>
<p>index就是列表对象（变量）内置的方法。</p>
<h3 id="列表的修改功能（方法）"><a href="#列表的修改功能（方法）" class="headerlink" title="列表的修改功能（方法）"></a>列表的修改功能（方法）</h3><ul>
<li><p>修改列表中的元素<br>语法：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">列表频[下标] = 值</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>向列表中指定位置插入元素<br>语法：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">列表.insert(下标，元素)</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="追加元素"><a href="#追加元素" class="headerlink" title="追加元素"></a>追加元素</h3><ul>
<li>将指定元素，追加到列表的尾部</li>
</ul>
<p>语法：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">列表.append(元素)</span><br></pre></td></tr></table></figure></div>
<p>如果要追加一批元素：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">列表。extend(其他数据容器)</span><br></pre></td></tr></table></figure></div>
<ul>
<li>将其他数据容器的内容取出，依次追加到列表尾部</li>
</ul>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>语法1：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">del 列表[下标]</span><br></pre></td></tr></table></figure></div>
<p>语法2：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">列表.pop(下标)</span><br></pre></td></tr></table></figure></div>
<p>pop这个方法实际上是取出这个元素，并且返回，所以可以定义一个变量去接收这个被取出来的元素。</p>
<p>语法3：</p>
<ul>
<li>不指定下标，而是指定元素的内容进行删除</li>
<li>从前到后去找这个元素，并且找到的第一个被删掉<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">列表.remove(元素)</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="清空列表"><a href="#清空列表" class="headerlink" title="清空列表"></a>清空列表</h3><p>语法:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">列表.clear()</span><br></pre></td></tr></table></figure></div>
<h3 id="统计某个元素在列表内的数量"><a href="#统计某个元素在列表内的数量" class="headerlink" title="统计某个元素在列表内的数量"></a>统计某个元素在列表内的数量</h3><p>语法：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">count = 列表.count(元素)</span><br></pre></td></tr></table></figure></div>
<h3 id="统计列表中总共有多少个元素"><a href="#统计列表中总共有多少个元素" class="headerlink" title="统计列表中总共有多少个元素"></a>统计列表中总共有多少个元素</h3><p>语法：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">count = len(列表)</span><br></pre></td></tr></table></figure></div>

<h2 id="2-4-列表的特点"><a href="#2-4-列表的特点" class="headerlink" title="2.4 列表的特点"></a>2.4 列表的特点</h2><ul>
<li>列表可以容纳多个元素(上限为2*63-1个)</li>
<li>可以容纳不同类型的元素(混装)</li>
<li>数据是有序存储的(有下标序号)</li>
<li>允许重复数据存在</li>
<li>可以修改(增加或删除元素等等)</li>
</ul>
<h2 id="2-5-列表的遍历"><a href="#2-5-列表的遍历" class="headerlink" title="2.5 列表的遍历"></a>2.5 列表的遍历</h2><ul>
<li><p>将容器内的元素依次取出进行处理的行为，称之为：遍历，迭代。</p>
</li>
<li><p>通过while、for循环来遍历列表的元素。</p>
</li>
</ul>
<p>循环条件如何控制？</p>
<ul>
<li>定义一个变量表示下标，这个变量从0开始。</li>
<li>循环的条件就是 下标值 &lt; 列表的元素数量</li>
</ul>
<p>for与while的区别：  </p>
<ol>
<li>循环控制上</li>
</ol>
<ul>
<li>while循环可以自定义循环条件，自行控制。</li>
<li>for不可以自定义循环条件，只可以一个个从容器内取出数据。</li>
</ul>
<ol start="2">
<li>无限循环上</li>
</ol>
<ul>
<li>while循环可以通过条件控制做到无限循环。</li>
<li>for理论上是不可以实现无限循环，因为遍历的容器容量不是无限的。</li>
</ul>
<ol start="3">
<li>在使用场景上：</li>
</ol>
<ul>
<li>while循环适用于任何想要循环的场景。</li>
<li>for循环适用于遍历数据容器的场景或者简单的固定次数循环的场景。</li>
</ul>
<h2 id="3-元组"><a href="#3-元组" class="headerlink" title="3.元组"></a>3.元组</h2><h3 id="3-1-元组的基本概念与定义"><a href="#3-1-元组的基本概念与定义" class="headerlink" title="3.1 元组的基本概念与定义"></a>3.1 元组的基本概念与定义</h3><p> 有了列表，为什么还需要元组？</p>
<ul>
<li>因为列表是可以修改的，但是如果响应传递的信息，不被修改，列表就不合适了。</li>
</ul>
<p><strong>元组一旦定义完成，就不可修改。可以认为元组就是一个只读的list</strong></p>
<p>所以元组应用于我们需要在程序内封装数据，但是又不希望数据被篡改。</p>
<p>定义语法：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 定义元组字面量</span><br><span class="line">(元素，元素，元素，……)</span><br><span class="line"></span><br><span class="line"># 定义元组变量</span><br><span class="line"></span><br><span class="line">变量名称 = (元素，元素，元素，……)</span><br><span class="line"></span><br><span class="line"># 定义空元组</span><br><span class="line"></span><br><span class="line">变量名称= ()</span><br><span class="line"></span><br><span class="line">变量名称 = tuple()</span><br></pre></td></tr></table></figure></div>

<p>注意事项：</p>
<ul>
<li><strong>如果元组只有一个数据，这个数据后面也要添加括号。否则就不是元组类型了。</strong></li>
<li>元组也可以嵌套(用法参考列表的嵌套)</li>
<li>如果print直接输出元组或者列表的话幂级数把里面的元素都打印出来。（加一个小括号或者中括号。反正就是元组或者列表怎么定义，就怎么打印）</li>
</ul>
<h3 id="3-2-元组的相关操作"><a href="#3-2-元组的相关操作" class="headerlink" title="3.2 元组的相关操作"></a>3.2 元组的相关操作</h3><p>由于元组的不可修改的特性，所以元组的相关操作没有列表那么多。</p>
<p>只有下面三种操作：</p>
<ol>
<li><p>index()方法：查找某个数据，如果数据存在就返回对应的下标，否则报错。</p>
</li>
<li><p>count()方法，统计某个数据在当前元组出现的次数。</p>
</li>
<li><p>len(元组)：统计元组内的元素个数。</p>
</li>
</ol>
<p>特别注意：</p>
<p><strong>元组不可以修改，但是如果元组里面嵌套一个list，这个list是可以修改的！</strong></p>
<h3 id="3-3元组的特点"><a href="#3-3元组的特点" class="headerlink" title="3.3元组的特点"></a>3.3元组的特点</h3><ol>
<li><p>可以容纳多个数据</p>
</li>
<li><p>可以容纳不同类型的数据(混装)</p>
</li>
<li><p>数据是有序存储的(下标索引)</p>
</li>
<li><p>允许重复数据存在</p>
</li>
<li><p><strong>不可以修改</strong>（除非嵌套了list）</p>
</li>
<li><p>支持for循环</p>
</li>
</ol>
<p>（多数特点和list一致。不同点在于不可修改的特性）</p>
<h2 id="4-再识字符串"><a href="#4-再识字符串" class="headerlink" title="4. 再识字符串"></a>4. 再识字符串</h2><p>字符串看上去并不像列表元组那样一看就是存放很多数据的容器。但是不可否认的是，字符串同样也是数据容器的一员。</p>
<p>字符串是字符的容器，一个字符串可以存放任意数量的字符。</p>
<ul>
<li>字符串的下标索引和list、元组是一样的。</li>
<li>和元组一样，字符串是一个<strong>不可修改的数据容器。</strong></li>
</ul>
<p>字符串的方法：</p>
<ol>
<li><p>index()方法</p>
</li>
<li><p>字符串.replace(字符串1，字符串2)。功能：将字符串内的全部：字符串1替换为字符串2。注意这里不是修改字符串本身，老的字符串不变，而是得到一个新的字符串，！</p>
</li>
<li><p>字符串.split(分隔符字符串)。功能：按照指定的分隔符字符串，将字符串划分为多个字符串，并存入列表对象。注意：字符串本身不变，而是得到一个列表对象的。这里的分隔符字符串是你自己定义的，可以是空格，也可以是每一个字符串片段。</p>
</li>
<li><p>字符串.strip。功能：字符串的规整操作，可以去掉前后空格。strip还可以再传入一个字符串作为参数，就可以去掉前后指定的字符串了。注意：如果参数写的是“12”，并不是只找12的字符串去删掉，而是，只要满足其中一个，也就是满足1或者满足2的我都去掉。</p>
</li>
<li><p>字符串.count(“指定的字符串”)方法，功能：统计字符串中指定字符串的出现次数。</p>
</li>
<li><p>len(字符串)。功能：统计字符串的字符个数。</p>
</li>
</ol>
<p>字符串特点：</p>
<ol>
<li><strong>只可以存储字符串</strong></li>
<li>长度任意</li>
<li>支持下标索引</li>
<li>允许重复字符串存在</li>
<li><strong>不可以修改！</strong></li>
<li>支持for循环</li>
</ol>
<h2 id="5-数据容器-序列-的切片操作"><a href="#5-数据容器-序列-的切片操作" class="headerlink" title="5.数据容器(序列)的切片操作"></a>5.数据容器(序列)的切片操作</h2><p>什么是序列？</p>
<ul>
<li>序列是指：内容连续，有序，可以使用下标索引的一类数据容器。列表，元组，字符串均可以视为序列。</li>
</ul>
<p>序列支持切片，也就是：列表，元组，字符串支持切片操作。</p>
<p>切片：从一个序列中，取出一个子序列。</p>
<p>语法：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">序列[起始下标：结束下标：步长]</span><br></pre></td></tr></table></figure></div>

<p>表示：从序列中，从指定位置开始，依次取出元素，到指定位置结束，得到一个新序列。</p>
<ul>
<li><p>起始下标表示从何处开始，可以留空，留空视作从头开始。</p>
</li>
<li><p>结束下标（不含）表示何处结束，可以留空，留空视作截取到结尾。</p>
</li>
<li><p>步长表示，依次取元素间隔。（步长1表示一个个取元素，步长2表示每次跳过一个元素取，步长N表示，每次跳过N-1个元素取。步长为负数表示，反向取（注意，起始下标和结束下标也要方向标记）</p>
</li>
</ul>
<p>注意：</p>
<ul>
<li>切片操作并不会影响序列本身，而是会得到新的序列。（因为元组和字符串都不能修改）</li>
</ul>
<p>写法可以这样子：</p>
<p>1.先倒序字符串再切片取出：</p>
<p>result &#x3D; my_strp[::-1][9:14]</p>
<ol start="2">
<li>先切片取出再倒序：</li>
</ol>
<p>result &#x3D; my_strp[5:10][::-1]</p>
<p>这个字符串的操作可以一连串写下来的。</p>
<p>举个例子：</p>
<p>result &#x3D; my_str(“,”)[1].replace(“来”，””)[::1]</p>
<hr>
<h2 id="6-set-集合"><a href="#6-set-集合" class="headerlink" title="6. set(集合)"></a>6. set(集合)</h2><p>为什么还要集合？<br>列表、元组、字符串都支持元素重复并且有序。</p>
<p>集合最主要的特点就是不支持重复的元素内容，也就是自带去重功能。而且内容是无序的。</p>
<p>定义语法：</p>
<ol>
<li>定义集合字面量<br>{元素，元素，……}</li>
<li>定义集合变量<br>变量名称 &#x3D; {变量，变量，……}</li>
<li>定义空集合<br>变量名称 &#x3D; set()</li>
</ol>
<p>注意：</p>
<ul>
<li><p>定义集合的时候，元素如果有重复的话，运行的话，程序并不会报错，但是重复的内容会自动去重，结果里面就不会重复了。</p>
</li>
<li><p>最后输出显示的时候并不会是定义时候的顺序，所以是乱序的。</p>
</li>
</ul>
<p><strong>因为集合是无序的，所以集合并不支持下标索引访问，集合的下标是没有意义的。所以集合不是序列！</strong></p>
<p><strong>但是集合和列表是一样的，是允许修改的。</strong></p>
<h3 id="集合的常用操作："><a href="#集合的常用操作：" class="headerlink" title="集合的常用操作："></a>集合的常用操作：</h3><ol>
<li><p>添加新的元素 ： 集合.add(元素)。将指定元素，添加到集合内。</p>
</li>
<li><p>移除元素 : 集合.remove(元素)，将指定元素，从集合内移除。</p>
</li>
<li><p>从集合中随机取出元素 ： 集合.pop ，会得到一个元素的结果，同时集合本身被修改，元素被移除。</p>
</li>
<li><p>清空集合 ： 集合.clear() 。</p>
</li>
<li><p>取出两个集合的差集 ： 集合1.difference(集合2) 。功能：取出集合1有但是集合2没有的，得到一个新的集合，集合1和集合2不变。</p>
</li>
<li><p>消除两个集合的差集 ： 集合1.difference_update(集合2) ，功能：在集合1内，删除和集合2相同的元素。结果：集合1被修改，集合2不变。</p>
</li>
<li><p>两个集合合并 ， 集合1.union(集合2) ，功能：将集合1和集合2组合得到新的集合。 结果： 得到新集合，集合1和集合2不变。</p>
</li>
<li><p>统计集合元素数量 ， len(集合)。如果元素重复了，按去重以后的数量计算得到结果。</p>
</li>
<li><p>因为集合不支持下标索引，所以不能用while循环！只能用for循环。</p>
</li>
</ol>
<h2 id="7-dict-字典"><a href="#7-dict-字典" class="headerlink" title="7.dict(字典)"></a>7.dict(字典)</h2><p>类比于生活中的字典，生活中的字典通过’字’找到对应的‘含义’。</p>
<p><strong>Python通过Key找到对应的Value</strong></p>
<p>字典的定义： </p>
<ol>
<li>定义字典字面量</li>
</ol>
<p>{key:value,key:value,……}</p>
<ol start="2">
<li><p>定义字典变量<br>my_dick &#x3D; {key：value,key:value,……}</p>
</li>
<li><p>定义空字典<br>my_dick &#x3D; {}<br>my_dick &#x3D; dick()</p>
</li>
</ol>
<p>字典的定义同样**使用{}**，不过存储的元素是一个个的： <strong>键值对</strong></p>
<ul>
<li><p>Key肯定是不能重复的！因为要通过Key找到value，如果有两个一样的Key，那么用的是哪个value就不知道了。如果两个Key一样，代码不会报错，而是后面的Key的value会覆盖前面那个相同的key的value。</p>
</li>
<li><p>字典是通过key取得对应的value，所以，字典和集合一样，不可以使用下标索引。</p>
</li>
</ul>
<p>使用上来说：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">字典[key] </span><br></pre></td></tr></table></figure></div>
<p>就可以得到对应的value</p>
<ul>
<li><p>字典的key和value可以是任意的数据类型，除了key不能是字典！</p>
</li>
<li><p>字典也是可以嵌套的。比如姓名作为key，考试成绩作为value，但是考试成绩有好几个科目啊，所以value也是可以作为字典。然后value作为字典，里面的key是语文数学等等科目，然后value是成绩。</p>
</li>
<li><p>从嵌套的字典里面取出value的写法也是类似于二维数组那个样子的。比如：字典[“陈鸣”][“语文”]，取出来就是陈鸣的语文成绩。</p>
</li>
</ul>
<h3 id="字典的常用操作"><a href="#字典的常用操作" class="headerlink" title="字典的常用操作"></a>字典的常用操作</h3><ol>
<li><p>新增元素:字典[key] &#x3D; Value ,结果：字典被修改，新增了元素</p>
</li>
<li><p>更新元素： 字典[key] &#x3D; value ，结果：字典被修改，元素被更新。</p>
</li>
</ol>
<p>注意 ：</p>
<ul>
<li>字典的key不可以重复，所以对已经存在的key执行上述操作，就是更新value值。</li>
<li>如果是嵌套字典，可以直接把第一层的字典所包含的内容先赋值给一个新字典（相当于复制一份新的字典）。然后在这个新的字典上修改信息，最后再反向新的字典直接赋值给第一层字典。（虽然绕了点，但是告诉我们可以直接拿字典作为一个整体直接赋值过去）。<br>具体可以看<a class="link"   href="https://www.bilibili.com/video/BV1qW4y1a7fU?t=454.2&p=77" >黑马的Python <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
<ol start="3">
<li><p>删除元素：字典pop(key) ，结果：会返回这个value，然后字典中的这个key和value都会被删除。</p>
</li>
<li><p>清空元素 ：字典.clear</p>
</li>
<li><p>获取全部key ：字典.keys() ,结果：获取字典中的全部key</p>
</li>
<li><p>统计字典的元素数量 ： len(字典) </p>
</li>
<li><p>获取了全部的key有什么用呢？拿来遍历字典。或者也可以直接对字典进行for循环，每一次循环但是直接得到key。</p>
</li>
<li><p>字典不支持下标索引，所以不能用while循环。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>格式化的精确控制 &amp; 数据输入（input语句）</title>
    <url>/2023/07/14/%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%9A%84%E7%B2%BE%E7%A1%AE%E6%8E%A7%E5%88%B6%20&amp;%20%E6%95%B0%E6%8D%AE%E8%BE%93%E5%85%A5%EF%BC%88input%E8%AF%AD%E5%8F%A5%EF%BC%89/</url>
    <content><![CDATA[<h1 id="格式化的精度控制"><a href="#格式化的精度控制" class="headerlink" title="格式化的精度控制"></a>格式化的精度控制</h1><p>使用m.n控制数据的宽度和精度。<br>m，控制宽度，要求是数字（很少用），如果设置的宽度小于数字自身，不生效。<br>.n，控制小数点精度，要求是数字，<strong>会进行小数的四舍五入，数据会失真</strong></p>
<h2 id="字符串快速格式化"><a href="#字符串快速格式化" class="headerlink" title="字符串快速格式化"></a>字符串快速格式化</h2><p>语法：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">f&quot;内容&#123;变量&#125;&quot;</span><br></pre></td></tr></table></figure></div>

<p> 此时的变量不限制数据类型，不会进行进度控制，会原样输出。这里的大括号就是占位符。</p>
<p>比如：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;qiemi&quot;</span></span><br><span class="line">age = <span class="number">18</span></span><br><span class="line">printf(<span class="string">f&quot;我是<span class="subst">&#123;name&#125;</span>,我今年<span class="subst">&#123;age&#125;</span>岁了&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<p>特点：</p>
<ol>
<li><p>不理会类型（类似于c++的cout）</p>
</li>
<li><p>不做精度控制（适合对精度没有要求的时候快速使用）</p>
</li>
</ol>
<h2 id="对表达式格式化"><a href="#对表达式格式化" class="headerlink" title="对表达式格式化"></a>对表达式格式化</h2><p>首先，什么是表达式？</p>
<p>表达式：一条具有<strong>明确执行结果</strong>的<strong>代码语句</strong>。<br>比如“</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1+1</span><br><span class="line">2*2</span><br><span class="line">name = &quot;qiemi&quot;</span><br><span class="line">age = 19</span><br></pre></td></tr></table></figure></div>


<p>表达式的格式化：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;1+1的结果是： %d&quot;</span> %(<span class="number">1</span>+<span class="number">1</span>)) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;9*9的结果是： <span class="subst">&#123;<span class="number">9</span>*<span class="number">9</span>&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;字符串在Python里面的的类型是 ：%s&quot;</span> % <span class="built_in">type</span>(<span class="string">&#x27;字符串&#x27;</span>))</span><br></pre></td></tr></table></figure></div>

<p>适合在不需要变量进行数据存储的时候，可以直接格式化表达式，简化代码。</p>
<h1 id="数据输入（input语句）"><a href="#数据输入（input语句）" class="headerlink" title="数据输入（input语句）"></a>数据输入（input语句）</h1><p>语法：<br>使用一个变量接收（存储）input语句获取的键盘输入数据即可</p>
<p>比如：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;请输入你的名字&quot;</span>)</span><br><span class="line">name = <span class="built_in">input</span>();</span><br></pre></td></tr></table></figure></div>
<p>上述例子的print其实是多余的，因为input语句自身就可以输出提示内容。所以可以进行简化：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="built_in">input</span>(<span class="string">&quot;请输入你的名字&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<p><strong>！！！input语句不管你写入的是什么数据，默认统统当做字符串看待！！！所以记得进行对应的数据类型转换</strong></p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>pid控制算法</title>
    <url>/2023/07/18/pid%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="PID"><a href="#PID" class="headerlink" title="PID"></a>PID</h1><ol>
<li>介绍pid</li>
</ol>
<ul>
<li>引言：如果不用PID算法，想要让小车前进100米，那就要得到小车的速度，然后100&#x2F;v得到小车前进的时间，然后让小车在这段时间内一直前进就好了。<br>这种控制叫做开放回路控制系统。因为机器人的输出(也就是机器人的位置)并不会发过来影响机器人的输入(也就是电机的转动)。</li>
</ul>
<p>这种方式在要求不高的场合是可以的。但是如果小车在运动过程中发生了偏移，或者前进的路面是不平坦的，又或者是机器人的速度慢了一点点，那么机器人就永远达到不了预期的100米位置。</p>
<p>因此在这种情况下，我们更加需要的是一种，闭环的控制系统。也就是输出会返回来影响输入，也就是引入反馈，利用反馈，去弥补干扰，比如说干扰让输出减小了1，反馈就让输出再多1。PID是闭环控制的一种，pid也是应用最为广泛的一种。</p>
<ol start="2">
<li>闭环控制系统<br>（pid适合于二阶以内的线性系统：满足齐次性和叠加性）<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image-1.png"
                      alt="Alt text"
                ></li>
</ol>
<ul>
<li>单闭环：引入了闭环控制系统，信号的输入在输入到控制器之前会先进行因此运算，E(误差，也就是净输入) &#x3D; X(输入) - Y(反馈) ，然后控制器计算得到控制信号Uc，给到执行器，执行器作用到对象，对象再输出Y反馈回去。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image-2.png"
                      alt="Alt text"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image-3.png"
                      alt="Alt text"
                ></p>
<ul>
<li>双闭环 ：内层的环相当于可以控制管道内的流量变化不会剧烈变化。</li>
</ul>
<ol start="3">
<li>参数详解</li>
</ol>
<ul>
<li>误差：输入减去输出，也就是净输入。</li>
<li>控制器输出：将误差经过运算，得到需要执行器执行的量。（可以理解为水阀需要扭多少角度）</li>
<li>执行器输出：接收到了控制器输出以后，执行器做出对应的输出。（可以理解为水阀打开的开口的大小）</li>
<li>系统输出：就是最后对象的输出，实际的输出，可以理解为最后输出的水流量。</li>
</ul>
<ol start="4">
<li>pid公式</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image-4.png"
                      alt="Alt text"
                ><br>C是输出，e是误差，也就是净输入。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image-5.png"
                      alt="Alt text"
                ><br>最后就是用下面那个公式去实现pid的。<br>控制器的输出就等于kp乘以误差 + ki乘以误差的累积 + kd乘以误差的变化值。</p>
<ol start="5">
<li>形象解释PID各个参数的含义<br>举个例子:</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image-6.png"
                      alt="Alt text"
                ><br>在这种单p控制时候下的位置和速度的变化如下图：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image-7.png"
                      alt="Alt text"
                ><br><strong>P值越大，速度越大，到达期望的时间越短。</strong></p>
<p>再举个例子：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image-8.png"
                      alt="Alt text"
                ><br>假设无人机的航模电机的转速达到100转&#x2F;分钟的时候才会和无人机自身重力平衡，无人机就达到悬停。</p>
<p>那么如果无人机一开始在地面上，实际高度是0，然后P是1，那么P<em>误差，刚刚好就是100，所以无人机在地面无法起飞。如果P等于2，那么无人机起飞到50m的时候，P</em>误差又等于100了，无人机就悬停在了50m的位置。如果P给100，无人机就会悬停在99米的位置。如果P给1000，无人机就悬停在了99.9米的位置。</p>
<ul>
<li>可见，用于无人机自身的重力的存在，所以无人机想要达到目标高度是和小车不一样的，如果只靠P的话，只能无限接近期望高度，是永远也达不到期望高度的。</li>
</ul>
<p>所以就要引入I，假设现在无人机飞到了99米，距离期望高度还有1m，但是无人机悬停了，不能往上再飞了，这个1m就叫做<strong>稳态误差</strong>。稳态误差一般就是用I弥补的。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image-9.png"
                      alt="Alt text"
                ><br>P设定完了就不变了，到达99米的时候，由P产生的升力只够维持无人机悬停了。积分I是根据以往的误差积累的，那么现在的误差是不变的，I就会一直线性增加，那么I加上P就产生一个新的升力，然后无人机就可以继续上升，理想情况下无人机就可以达到理想高度。</p>
<p>那么现在达到目标高度了，误差等于0了，由P产生的升力也等于0了。<br>升力由积分项提供，积分不受当前状态的影响，只受以前所有误差的积累的影响。所以积分项不会因为现在的误差变成0而变了。他只是不再积累了。但是积分项不是0哦！所以此时悬停的工作就给了I。</p>
<p>那现在来说D！如果P一开始是100，误差一开始也是100.那么一开始的升力就达到了10000，太大了。积分项从100一直积分下去也是挺大的。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image-10.png"
                      alt="Alt text"
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image-11.png"
                      alt="Alt text"
                ><br>也就是P和I在一开始的时候会非常大。<br>无人机就会直接冲过100米，可能飞到150米然后再飞回来……<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image-12.png"
                      alt="Alt text"
                ><br>比如这样子。</p>
<p>所以就要引入微分。微分就是对误差进行求导。导数值就是微分项。一开始PI都是正的，导致E误差是在下降的，所以对误差求导得到的D就是负的，所以D就可以去抵消PI。</p>
<ol start="6">
<li>调参</li>
</ol>
<p>慢慢调大Kp，直到差不多达到期望高度。然后加入Ki，Ki小一点消除误差效果就差一点反之……发现有超调现象就调大Kd，但是如果Kd太大了会严重影响系统的调节时间，让系统调节时间很长。</p>
<ul>
<li>调大Kp直到接近期望高度。</li>
<li>加入Ki，先给小，然后慢慢加大。然后就接近贴合了。</li>
<li>但是有时候对于时间有要求的，所以Ki继续给大，就会出现超调了。一般来说引入PI就可以了，如果超调，震荡很明显就引入Kd。</li>
</ul>
<ol start="7">
<li>其余相关控制知识</li>
</ol>
<ul>
<li>积分限幅：假设现在有人在无人机起飞的时候一直按着无人机，那么无人机无法起飞，误差一直是100，积分I就一直积分一直积分，积分到很大。然后这个人突然放手，此时不仅有一个很大的I，P也参与进来，此时升力就非常非常非常大，无人机就会一飞冲天了。所以就要给积分项一个限制，积分项升到多大的时候就不能再升了。</li>
<li>积分分离：比如现在飞机悬停在了100m了，只靠着I产生的升力悬停。如果突然修改期望高度到1000m，那么误差项就会突变，然后积分项也会随着突然增大很多。也会导致超调。所以可以引入一个判断，如果误差大于某个值的时候，就让积分项等于0，先不用积分项，然后单单只靠P，来把误差变小，然后误差小于一定值再引入I。</li>
<li>微分先行：不再是让误差直接传给D，而是输出通过传感器传给D，这样子如果期望高度突变，影响是先给到P和I，不会马上给D，这样子就消除了输入突变的影响。</li>
</ul>
<ol start="8">
<li>理论到实际<br>示例1：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image-13.png"
                      alt="Alt text"
                ><br>控制器就是根据PID的那个公式算得的结果，然后根据CAN协议传给执行器，也就是电调。然后电调给对应的电机电流，然后电机的输出（可以是电机的转速）反馈回去再进行一次pid控制。</li>
</ol>
<p>代码讲解：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image-14.png"
                      alt="Alt text"
                ><br>首先还要定义一下我们的期望输出：</p>
<ul>
<li>………….speedPID.target &#x3D; 500; &#x2F;&#x2F;期望输出是电机没秒500转</li>
</ul>
<p>然后代码第一行就是获取现在的转速，也就是反馈量。从电机发回来的数据包里面拿到这个转速。<br>然后调用pid_calc这个函数，函数的定义在下面。</p>
<ul>
<li>这个算法的第一句就是输入减去输出得到误差值，也就是净输入。</li>
</ul>
<p>然后要把这个误差值给到控制器。</p>
<ul>
<li>就是第二句就是把算出来的误差e去乘以比例Kp。</li>
<li>第三句就是累加积分。</li>
<li>else语句下面的第一句就是计算D</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image-15.png"
                      alt="Alt text"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image-16.png"
                      alt="Alt text"
                ><br>P,I,D都算出来了，根据公式或者是流程图，得把他们加起来了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image-17.png"
                      alt="Alt text"
                ><br>所以这里就是在求和。</p>
<ul>
<li><p>还有积分限幅和积分分离，这两个都标记了注释，很好理解。</p>
</li>
<li><p>最后的的输出限幅是最后的安全保障。</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image-18.png"
                      alt="Alt text"
                ><br>特别注意！代码只是演示。实际上使用，这两部分用一个就行了，如果两个都写进去就一次循环里面积分了两次！是错误的。</p>
<p>如果既想要积分限幅又想要积分分离，那就把第三句的积分去掉，只留下积分分离里面的积分就好了。然后再把积分限幅放到积分分离的累加积分的那一句的下面就行了。</p>
<p>最后经过公式，求和以后得到的pid_total就是给到执行器的数据。然后执行器执行到对象，然后对象再输出一个反馈量回去。</p>
<p>示例2：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image-19.png"
                      alt="Alt text"
                ><br><a class="link"   href="https://www.bilibili.com/video/BV1B54y1V7hp?t=855.8&p=5" >点我，看具体细节 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image-20.png"
                      alt="Alt text"
                ></p>
]]></content>
      <tags>
        <tag>PID</tag>
      </tags>
  </entry>
</search>
