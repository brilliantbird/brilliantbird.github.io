<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2023/07/07/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>Markdown</title>
    <url>/2023/07/14/Markdown/</url>
    <content><![CDATA[<h1 id="一、Markdown简介"><a href="#一、Markdown简介" class="headerlink" title="一、Markdown简介"></a>一、Markdown简介</h1><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p>
<p>Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。</p>
<p>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。</p>
<p>Markdown 编写的文档后缀为 .md, .markdown。</p>
<p>Markdown 能被使用来撰写电子书，如：Gitbook。</p>
<p>当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge等。</p>
<h1 id="二、Markdown标题"><a href="#二、Markdown标题" class="headerlink" title="二、Markdown标题"></a>二、Markdown标题</h1><p>使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。<br><strong>注意：#后面一定要跟着空格，否则语法无效！</strong></p>
<p>标题内容的后面如果也存在空格和 #，也可以构成标题，且标题的级别以前面 # 的数量为准。</p>
<p><strong>使用#号标记标题语法格式：</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line"></span><br><span class="line">## 二级标题</span><br><span class="line"></span><br><span class="line">### 三级标题</span><br><span class="line"></span><br><span class="line">#### 四级标题</span><br><span class="line"></span><br><span class="line">##### 五级标题</span><br><span class="line"></span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure></div>
<p>显示效果：<br>[TOC]目录</p>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h1 id="三、Markdown段落"><a href="#三、Markdown段落" class="headerlink" title="三、Markdown段落"></a>三、Markdown段落</h1><p>Markdown的段落没有特殊的格式，直接编写文字就好，段落的换行号是使用两个以上的空格加回车。</p>
<h2 id="3-1字体"><a href="#3-1字体" class="headerlink" title="3.1字体"></a>3.1字体</h2><p>Markdown 可以使用以下几种字体：</p>
<ul>
<li>用1个星号*或底线_表示斜体</li>
<li>用2个星号*或底线_表示粗体</li>
<li>用3个星号*或底线_表示粗斜体</li>
</ul>
<p>语法格式：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">*斜体文字*</span><br><span class="line"></span><br><span class="line">_斜体文字_</span><br><span class="line"></span><br><span class="line">**粗体文字**</span><br><span class="line"></span><br><span class="line">__粗体文字__</span><br><span class="line"></span><br><span class="line">***粗斜体文字***</span><br><span class="line"></span><br><span class="line">___粗斜体文字___</span><br></pre></td></tr></table></figure></div>

<p>显示效果：</p>
<p><em>斜体文字</em></p>
<p><em>斜体文字</em></p>
<p><strong>粗体文字</strong></p>
<p><strong>粗体文字</strong></p>
<p><em><strong>粗斜体文字</strong></em></p>
<p><em><strong>粗斜体文字</strong></em></p>
<h2 id="3-2分隔线"><a href="#3-2分隔线" class="headerlink" title="3.2分隔线"></a>3.2分隔线</h2><p>可以在一行中用三个以上的星号*、减号-、底线_来建立一个分隔线，行内不能有其他东西，你也可以在星号或减号蹭插入空格。下面这种写法都可以建立分隔线：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">***</span><br><span class="line">* * *</span><br><span class="line">******</span><br><span class="line">- - -</span><br><span class="line">------</span><br></pre></td></tr></table></figure></div>

<h2 id="显示效果："><a href="#显示效果：" class="headerlink" title="显示效果：**** * *******- - -"></a>显示效果：<br>***<br>* * *<br>******<br>- - -</h2><h2 id="3-3删除线"><a href="#3-3删除线" class="headerlink" title="3.3删除线"></a>3.3删除线</h2><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线~~即可。</p>
<p>语法格式：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">~~要显示为要删除线的字~~</span><br></pre></td></tr></table></figure></div>

<p>显示效果：</p>
<p><del>要显示为要删除线的字</del></p>
<h2 id="3-4下划线"><a href="#3-4下划线" class="headerlink" title="3.4下划线"></a>3.4下划线</h2><p>下划线可以通过HTML的标签来实现</p>
<p>语法格式：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;u&gt;带下划线文本&lt;/u&gt;</span><br></pre></td></tr></table></figure></div>

<p>显示效果：</p>
<p><u>带下划线文本</u></p>
<h1 id="四、Markdown列表"><a href="#四、Markdown列表" class="headerlink" title="四、Markdown列表"></a>四、Markdown列表</h1><h2 id="4-1有序列表和无序列表"><a href="#4-1有序列表和无序列表" class="headerlink" title="4.1有序列表和无序列表"></a>4.1有序列表和无序列表</h2><p>Markdown支持有序列表和无序列表，</p>
<p>无序列表使用星号(*)、加号(+)或者减号(-)作为标记：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 第一项</span><br><span class="line">* 第二项</span><br><span class="line">* 第三项</span><br><span class="line"></span><br><span class="line">+ 第一项</span><br><span class="line">+ 第二项</span><br><span class="line">+ 第三项</span><br><span class="line"></span><br><span class="line">- 第一项</span><br><span class="line">- 第二项</span><br><span class="line">- 第三项</span><br></pre></td></tr></table></figure></div>

<p>显示效果：</p>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<p>有序列表直接在文字有加上1. 2. 3. 来表示，符号和文字之间加上一个空格字符，如：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 第一项</span><br><span class="line">2. 第二项</span><br><span class="line">3. 第三项</span><br></pre></td></tr></table></figure></div>

<p>显示效果：</p>
<ol>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ol>
<h2 id="4-2列表嵌套"><a href="#4-2列表嵌套" class="headerlink" title="4.2列表嵌套"></a>4.2列表嵌套</h2><p>列表嵌套只需在子列表的选项前添加四个空格即可：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 第一项：</span><br><span class="line">    - 第一项嵌套的第一个元素</span><br><span class="line">    - 第一项嵌套的第二个元素</span><br><span class="line">2. 第二项：</span><br><span class="line">    - 第二项嵌套的第一个元素</span><br><span class="line">    - 第二项嵌套的第二个元素</span><br></pre></td></tr></table></figure></div>

<p>显示效果：</p>
<ol>
<li>第一项：<ul>
<li>第一项嵌套的第一个元素</li>
<li>第一项嵌套的第二个元素</li>
</ul>
</li>
<li>第二项：<ul>
<li>第二项嵌套的第一个元素</li>
<li>第二项嵌套的第二个元素</li>
</ul>
</li>
</ol>
<h1 id="五、引用"><a href="#五、引用" class="headerlink" title="五、引用"></a>五、引用</h1><p>Markdown区块引用是在段落开头使用&gt;符号，然后后面紧跟一个空格符号：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; 区块引用  </span><br><span class="line">&gt; Markdown教程  </span><br><span class="line">&gt; 学的不仅是技术更是梦想</span><br></pre></td></tr></table></figure></div>

<p>显示效果：</p>
<blockquote>
<p>区块引用<br>Markdown教程<br>学的不仅是技术更是梦想  </p>
</blockquote>
<p>另外区块是可以嵌套的，一个&gt;符号是最外层，两个符号是第一层嵌套，以此类推：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; 最外层</span><br><span class="line">&gt;&gt; 第一层嵌套</span><br><span class="line">&gt;&gt;&gt; 第二层嵌套</span><br></pre></td></tr></table></figure></div>

<p>显示效果：</p>
<blockquote>
<p>最外层</p>
<blockquote>
<p>第一层嵌套</p>
<blockquote>
<p>第二层嵌套</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="5-1区块引用中使用列表"><a href="#5-1区块引用中使用列表" class="headerlink" title="5.1区块引用中使用列表"></a>5.1区块引用中使用列表</h2><p>区块中使用列表实例如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; 区块中使用列表</span><br><span class="line">&gt; 1. 第一项</span><br><span class="line">&gt; 2. 第二项</span><br><span class="line">&gt; + 第一项</span><br><span class="line">&gt; + 第二项</span><br><span class="line">&gt; + 第三项</span><br></pre></td></tr></table></figure></div>

<p>显示效果：</p>
<blockquote>
<p>区块中使用列表</p>
<ol>
<li>第一项</li>
<li>第二项</li>
</ol>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
</blockquote>
<h2 id="5-2引用多个段落"><a href="#5-2引用多个段落" class="headerlink" title="5.2引用多个段落"></a>5.2引用多个段落</h2><p>引用可以包含多个段落，引用内段落和普通段落一样，不过在空行前面也要加上小于号。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; 这是一个引用段落</span><br><span class="line">&gt;</span><br><span class="line">&gt; 这是另一个引用段落</span><br></pre></td></tr></table></figure></div>

<p>显示效果：</p>
<blockquote>
<p>这是一个引用段落</p>
<p>这是另一个引用段落</p>
</blockquote>
<h1 id="六、Markdown代码块"><a href="#六、Markdown代码块" class="headerlink" title="六、Markdown代码块"></a>六、Markdown代码块</h1><h2 id="6-1行内代码"><a href="#6-1行内代码" class="headerlink" title="6.1行内代码"></a>6.1行内代码</h2><p>使用一对反引号(&#96;)来创建行内代码。如果在行内代码中需要包含反引号本身，可以使用两个反引号对加前后空格来创建。</p>
<h2 id="6-2代码块！"><a href="#6-2代码块！" class="headerlink" title="6.2代码块！"></a>6.2代码块！</h2><p>将文本的每一行缩进至少四个空格或一个制表符。这样这些文本会变成代码块。</p>
<h2 id="6-3围栏式代码块！"><a href="#6-3围栏式代码块！" class="headerlink" title="6.3围栏式代码块！"></a>6.3围栏式代码块！</h2><p>在很多 Markdown 解析器里都支持使用三个反引号(&#96;)或三个波浪号(~)来定义围栏式代码块。同时这种代码块配合插件还可以做到代码高亮、行号等高级功能。（如果在代码块中也存在三个反引号或波浪号，可以在外层使用 4 个。）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">```javascript</span><br><span class="line">const a = 1;</span><br><span class="line">const b = 2;</span><br><span class="line">function add(num1, num2) &#123;</span><br><span class="line">  return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">console.log(add(a, b));</span><br><span class="line">```</span><br></pre></td></tr></table></figure></div>

<p>显示效果：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(a, b));</span><br></pre></td></tr></table></figure></div>

<h1 id="七、Markdown链接"><a href="#七、Markdown链接" class="headerlink" title="七、Markdown链接"></a>七、Markdown链接</h1><h2 id="7-1链接到网站"><a href="#7-1链接到网站" class="headerlink" title="7.1链接到网站"></a>7.1链接到网站</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[茄迷的bolg](https://brilliantbird.github.io/)</span><br></pre></td></tr></table></figure></div>

<p>显示效果：</p>
<p><a class="link"   href="https://brilliantbird.github.io/" >茄迷的bolg <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="7-2高级链接"><a href="#7-2高级链接" class="headerlink" title="7.2高级链接"></a>7.2高级链接</h2><p>链接也可以用变量来代替，文档末尾附带变量地址：<br>这个链接用1作为网址变量<a class="link"   href="http://www.baidu.com/" >baidu <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>这个链接用markdown作为网址变量<a class="link"   href="http://www.markdown.com/" >Markdown <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>然后文档的结尾为变量赋值(网址)</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1]: http://www.baidu.com</span><br><span class="line">[markdown]: http://www.markdown.com</span><br></pre></td></tr></table></figure></div>
<p>显示效果：(我在写笔记的时候加了两句，但是这里并没有没有显示出来。加了两句超链接以后，baidu和Markdown就可以变成超链接点进去了)</p>
<h1 id="八、Markdown图片"><a href="#八、Markdown图片" class="headerlink" title="八、Markdown图片"></a>八、Markdown图片</h1><p>Markdown图片语法格式为：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">![alt 属性文本](图片地址)</span><br><span class="line">![alt 属性文本](图片地址 &quot;可选标题&quot;)</span><br></pre></td></tr></table></figure></div>

<ul>
<li>开头一个感叹号!</li>
<li>接着一个方括号，里面放上图片的代替文字</li>
<li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的’title’属性文字。</li>
</ul>
<p>举个例子：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">![帅哥照片](https://bkimg.cdn.bcebos.com/pic/b17eca8065380cd79123caf75208ba345982b2b72bde?x-bce-process=image/resize,m_lfit,h_4096,limit_1/watermark,image_d2F0ZXIvYmFpa2UyNzI=,g_7,xp_5,yp_5/format,f_auto)</span><br></pre></td></tr></table></figure></div>

<p><strong>1. 补充：带链接的图片</strong></p>
<p>下面的代码，把生成图片的代码放到了超链接的名称里面。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[![这是一个图片](/images/tutorials/markdown/工具页截图-dark.png)](/tools/)</span><br></pre></td></tr></table></figure></div>

<p><strong>2. 补充：带title的图片</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">![这是一个图片](/images/tutorials/markdown/工具页截图-dark.png &quot;这是工具页的截图&quot;)</span><br></pre></td></tr></table></figure></div>

<h1 id="九、Emoji表情"><a href="#九、Emoji表情" class="headerlink" title="九、Emoji表情"></a>九、Emoji表情</h1><p>在 Markdown 里使用 Emoji 表情有两种方法，一种是直接输入 Emoji 表情，另一种是使用 Emoji 表情短码(emoji shartcodes)。</p>
<p>Emoji 表情短码放到两个冒号(:)之间，比如： :joy:😂。</p>
<h1 id="十、表格"><a href="#十、表格" class="headerlink" title="十、表格"></a>十、表格</h1><p>表格使用竖线(|)区分每一列，在表格头和表格体之间第列使用至少三个减号(-)来做为分隔。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">|第一列|第二列|第三列|</span><br><span class="line">|---|---|---|</span><br><span class="line">|第一行第一列|第一行第二列|第一行第三列|</span><br><span class="line">|第二行第一列|第二行第二列|第二行第三列|</span><br></pre></td></tr></table></figure></div>

<p>显示效果：</p>
<table>
<thead>
<tr>
<th>第一列</th>
<th>第二列</th>
<th>第三列</th>
</tr>
</thead>
<tbody><tr>
<td>第一行第一列</td>
<td>第一行第二列</td>
<td>第一行第三列</td>
</tr>
<tr>
<td>第二行第一列</td>
<td>第二行第二列</td>
<td>第二行第三列</td>
</tr>
</tbody></table>
<p><strong>补充：设置表格的对齐方式</strong></p>
<p>下列代码，在第二行的每一列都添加了冒号(:)，左侧添加一个冒号表示该列左对齐，右侧添加一个冒号表示该列右对齐，左右各添加一个冒号表示该列居中对齐。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">|第一列|第二列|第三列|</span><br><span class="line">|:---|:---:|---:|</span><br><span class="line">|这一列是左对齐的|这一列是居中对齐的|这一列是右对齐的|</span><br></pre></td></tr></table></figure></div>

<p>显示效果：</p>
<table>
<thead>
<tr>
<th align="left">第一列</th>
<th align="center">第二列</th>
<th align="right">第三列</th>
</tr>
</thead>
<tbody><tr>
<td align="left">这一列是左对齐的</td>
<td align="center">这一列是居中对齐的</td>
<td align="right">这一列是右对齐的</td>
</tr>
</tbody></table>
<p>在表格中可以使用斜体单行元素，比如粗体斜体、行内代码、超链接、图片、Emoji表情、HTML等。</p>
<p>关于图表，公式，脚注，注释，内嵌HTML和React的相关内容未完待续！！！</p>
]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>判断语句</title>
    <url>/2023/07/15/%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h1 id="一、bool类型和比较运算符"><a href="#一、bool类型和比较运算符" class="headerlink" title="一、bool类型和比较运算符"></a>一、bool类型和比较运算符</h1><p>bool类型的本质还是数字类型，True的底层就是1，False底层就是0。</p>
<p>bool类型的数据不仅可以通过定义得到，也可以通过比较运算符（&#x3D;&#x3D;、&gt;、&lt;、!&#x3D;、&gt;&#x3D;、&lt;&#x3D;）进行内容比较得到。  </p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">bool_1 = Ture</span><br><span class="line">bool_2 = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">bool_3 = <span class="number">5</span>&gt;<span class="number">3</span></span><br><span class="line">bool_4 = <span class="number">1</span>&gt;<span class="number">6</span></span><br><span class="line">bool_5 = <span class="number">1</span> ==<span class="number">1</span></span><br></pre></td></tr></table></figure></div>

<h1 id="二、if语句的基本格式"><a href="#二、if语句的基本格式" class="headerlink" title="二、if语句的基本格式"></a>二、if语句的基本格式</h1><h2 id="2-1-if基本格式"><a href="#2-1-if基本格式" class="headerlink" title="2.1 if基本格式"></a>2.1 if基本格式</h2><p>语法格式：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 要判断的条件：</span><br><span class="line">    条件成立时要执行的语句</span><br></pre></td></tr></table></figure></div>
<p>细节：  </p>
<ul>
<li>冒号别少了</li>
<li>与c语言用大括号来判断归属关系不同的是Python是通过空格缩进来判断归属关系的！（四个空格缩进）</li>
<li>判断语句的结果必须是bool类型的True和False</li>
</ul>
<h2 id="2-2-if-else语句"><a href="#2-2-if-else语句" class="headerlink" title="2.2 if else语句"></a>2.2 if else语句</h2><p>语法格式：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">if 条件:</span><br><span class="line">    条件成立时要执行的语句</span><br><span class="line">else:</span><br><span class="line">    不满足的时候执行的语句</span><br></pre></td></tr></table></figure></div>

<p>注意 ：</p>
<ul>
<li>else不需要判断条件</li>
<li>else同样需要四个空格进行缩进</li>
</ul>
<h2 id="2-3-if-elif-else语句进行多条件判断的语法"><a href="#2-3-if-elif-else语句进行多条件判断的语法" class="headerlink" title="2.3 if elif else语句进行多条件判断的语法"></a>2.3 if elif else语句进行<strong>多条件判断</strong>的语法</h2><p>语法格式：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件<span class="number">1</span>：</span><br><span class="line">    ......</span><br><span class="line"><span class="keyword">elif</span> 条件<span class="number">2</span>：</span><br><span class="line">    ......</span><br><span class="line"><span class="keyword">elif</span> 条件<span class="number">3</span>：</span><br><span class="line">    ......</span><br><span class="line"><span class="keyword">else</span>：</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure></div>

<p><strong>可以实现多条件判断！！！先判断条件1满足不满足，然后再依次判断条件2，条件3……如果全部不满足就执行else</strong></p>
<p>注意：</p>
<ul>
<li>判断是互斥且<strong>有顺序的</strong></li>
<li>满足其中一个条件，执行完相关的语句以后就会跳出这个层次的if语句。</li>
<li>else可以不写</li>
<li>空格缩进同样不可省略</li>
</ul>
<p>举个例子：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">num == <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请猜一个数字： &quot;</span>)) == num：</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;猜对了&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;猜错了，再猜一个数字： &quot;</span>)) == num：</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;猜对了&quot;</span>)</span><br><span class="line"><span class="keyword">else</span> ：</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;猜错了&quot;</span>)</span><br></pre></td></tr></table></figure></div>
<p>这个例子告诉我们，if elif else是按顺序从上往下一个个执行的，其次可以在if的条件里面去写input函数，这样子代码更加简洁。别忘了把输入的数据转换成int类型后再进行比较！</p>
<h2 id="2-4判断语句的嵌套"><a href="#2-4判断语句的嵌套" class="headerlink" title="2.4判断语句的嵌套"></a>2.4判断语句的嵌套</h2><p>由于许多的逻辑的判断是嵌套的，多层次的。对于这种需求，我们可以自由组合if elif else ，完成特定需求的要求。</p>
<p>语法格式：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件<span class="number">1</span>：</span><br><span class="line">    …………</span><br><span class="line">    <span class="keyword">if</span> 条件<span class="number">2</span>：</span><br><span class="line">        …………</span><br><span class="line">        …………</span><br></pre></td></tr></table></figure></div>
<p>可以看到，只有条件1满足以后才会去判断条件2是否满足。<br>嵌套的关键在于<strong>空格缩进！！！</strong><br>还是记住：通过空格缩进来决定语句之间的：<strong>层次关系</strong></p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>函数</title>
    <url>/2023/07/16/%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>特点：</p>
<ul>
<li>已经组织好的</li>
<li>可重复使用</li>
<li>针对特定功能</li>
</ul>
<p>使用函数可以：得到一个针对特定需求、可供重复利用的代码段。提供程序的复用性、减少重复性代码，提高开发效率。  </p>
<h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><p>函数定义语法格式：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">函数名</span>(<span class="params">传入参数</span>):</span><br><span class="line">    函数体</span><br><span class="line">    <span class="keyword">return</span> 返回值</span><br></pre></td></tr></table></figure></div>

<p>函数调用：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数名(参数)</span><br></pre></td></tr></table></figure></div>
<p>注意：</p>
<ul>
<li>参数和返回值都可以省略</li>
<li>函数必须先定义后使用</li>
</ul>
<h2 id="函数的传入参数"><a href="#函数的传入参数" class="headerlink" title="函数的传入参数"></a>函数的传入参数</h2><p>示例：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x,y</span>)</span><br><span class="line">    result = x + y</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></div>
<ul>
<li>x,y称为形式参数，表示函数就要使用这两个参数。</li>
<li><strong>c参数之间用逗号分隔</strong></li>
<li>函数调用中，提供的参数称之为实际参数，表示函数执行的时候真正使用的参数值。</li>
<li>传入实际参数的时候，按照顺序传入数据，使用逗号分隔。</li>
<li>传入参数的个数是不受限制的，可以不使用参数，也可以仅使用任意的N个参数。</li>
</ul>
<h2 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h2><p><strong>通过return关键字将函数执行结果返回给函数的调用者。</strong></p>
<p>函数体遇到return以后就结束了，所以写在return后面的代码就不会执行了。</p>
<h2 id="None类型"><a href="#None类型" class="headerlink" title="None类型"></a>None类型</h2><p>如果函数没有使用return语句返回数据，函数也是有返回值的。Python中有一个特殊的字面量：None，类型是：&lt;class‘NoneType’&gt;，无返回值的函数，实际上就是返回了：None这个字面量。表示函数没有返回什么有意义的内容，也就是返回了空的意思。</p>
<p>应用场景：</p>
<ol>
<li><p>用在函数无返回值上</p>
</li>
<li><p>用在if判断中</p>
<ul>
<li>在if判断中，None等同于False</li>
<li>一般在函数中主动返回None，配合if判断做相关处理。</li>
</ul>
</li>
<li><p>用于声明无内容的变量上</p>
<ul>
<li>定义变量，但暂时不需要变量有具体值，可以用None来代替</li>
</ul>
</li>
</ol>
<h2 id="函数说明文档"><a href="#函数说明文档" class="headerlink" title="函数说明文档"></a>函数说明文档</h2><p>我们通过给函数添加说明文档，辅助理解函数的作用。</p>
<p>通过多行注释的形式，对函数进行说明解释。</p>
<ul>
<li>内容应写在函数体之前。</li>
</ul>
<p>建议的语法格式：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">x,y</span>)</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    函数说明</span></span><br><span class="line"><span class="string">    ：param x：形参x的说明</span></span><br><span class="line"><span class="string">    ：param y：形参y的说明</span></span><br><span class="line"><span class="string">    ：return： 返回值的说明</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>PyCharm会自动补全</li>
<li>在PyCharm编写代码的时候，通过鼠标悬停，可以查看调用函数的说明文档</li>
</ul>
<h2 id="函数的嵌套调用"><a href="#函数的嵌套调用" class="headerlink" title="函数的嵌套调用"></a>函数的嵌套调用</h2><p>定义： 在一个函数里面又调用另外一个函数。</p>
<ul>
<li>在函数A中，调用另外一个函数B，那么先把函数B的任务都执行完才会回到上次函数A执行的位置，继续往下面执行。</li>
</ul>
<h2 id="函数中的变量作用域"><a href="#函数中的变量作用域" class="headerlink" title="函数中的变量作用域"></a>函数中的变量作用域</h2><p>变量作用域指的是变量的作用范围（变量在哪里可用，在哪里不可用）<br>主要分为俩类：<strong>局部变量和全局变量</strong></p>
<p><strong>局部变量：定义在函数体内部的变量，就只能在函数体内部生效。</strong></p>
<p><strong>全局变量：在函数体内部和外部都可以生效的变量</strong></p>
<h3 id="global关键字"><a href="#global关键字" class="headerlink" title="global关键字"></a>global关键字</h3><p>如果在函数内部修改全局变量的值，那么该全局变量在这个函数内还是按照修改后的值允许，但是在函数的外面，该全局变量的值其实并没有发送改变。也就是说，该全局变量在函数体内部还是被看做是一个局部变量了，和外面的全局变量没有一点关系。</p>
<p>那么，我们就是想在函数内部将全局变量的值修改，要怎么办呢？</p>
<p>使用global关键字。</p>
<p>在函数体内通过global声明变量，以代表该变量是一个全局变量。</p>
<p><strong>总结：global关键字可以让在函数内定义的变量变成全局变量。</strong></p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>循环结构</title>
    <url>/2023/07/15/%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h1><h2 id="1-1while循环的基础使用"><a href="#1-1while循环的基础使用" class="headerlink" title="1.1while循环的基础使用"></a>1.1while循环的基础使用</h2><p>语法格式：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件：</span><br><span class="line">    条件满足时执行的语句……</span><br></pre></td></tr></table></figure></div>
<p><strong>只要条件（可以是bool或者比较运算）满足，就会无限循环执行</strong></p>
<h2 id="1-2while的嵌套循环"><a href="#1-2while的嵌套循环" class="headerlink" title="1.2while的嵌套循环"></a>1.2while的嵌套循环</h2><p>和if的嵌套几乎一模一样，只需要把if的嵌套中的if改成while就是while的嵌套循环了。</p>
<p><strong>注意：此处的嵌套循环同样是基于空格缩进来决定层次关系。</strong></p>
<hr>
<p>补充内容：</p>
<ol>
<li>默认print语句输出内容会自动换行，所以有时候也会用print语句输出空内容来实现换行。（与c语言不同）</li>
</ol>
<p>如果想要使用print语句，输出不换行的功能的话，需要这么写：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;World&quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure></div>
<ol start="2">
<li>制表符\t<br>效果等同于tab键，可以让多行字符串进行对齐。</li>
</ol>
<h2 id="示例：如此输出以后，上下俩行的上下两个字符串就会对齐！"><a href="#示例：如此输出以后，上下俩行的上下两个字符串就会对齐！" class="headerlink" title="示例：如此输出以后，上下俩行的上下两个字符串就会对齐！"></a>示例：<br><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(&quot;Hello\tWorld&quot;)</span><br><span class="line">print(&quot;qiemi\t666&quot;)</span><br></pre></td></tr></table></figure></div><br>如此输出以后，上下俩行的上下两个字符串就会对齐！</h2><h2 id="2-1-for循环基础语法"><a href="#2-1-for循环基础语法" class="headerlink" title="2.1 for循环基础语法"></a>2.1 for循环基础语法</h2><p>与while循环的区别：</p>
<ul>
<li>while循环的循环条件是自定义的，<strong>自行控制循环条件</strong></li>
<li>for循环是一种<strong>“轮询”</strong>机制，是对一批内容进行“逐个处理”</li>
</ul>
<p>语法格式：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 临时变量 <span class="keyword">in</span> 待处理数据集（序列):</span><br><span class="line">    循环满足条件时执行的代码</span><br></pre></td></tr></table></figure></div>

<ul>
<li>in是一个关键字</li>
<li>执行逻辑是从待处理数据集中的数据逐个取出，每个循环就将当前输出赋予这个临时变量，然后执行循环体内的代码。</li>
</ul>
<p>举个例子：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;cheming&quot;</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> name:</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>for循环是无法定义循环条件的，只呢从数据集里面依次取出内容进行处理，理论上来说Python的for循环无法构建无限循环。</p>
</li>
<li><p>同样有空格缩进</p>
</li>
</ul>
<h2 id="2-2-range语句"><a href="#2-2-range语句" class="headerlink" title="2.2 range语句"></a>2.2 range语句</h2><p>待处理数据集的严格说法叫做：序列类型。<br>序列类型指：内容可以一个个依次取出的一种类型。包括：</p>
<ul>
<li>字符串</li>
<li>列表</li>
<li>元组</li>
<li>等</li>
</ul>
<p>因此for循环语句，本质上是遍历：序列类型。</p>
<p>学习range语句，获得一个简单的数字序列：</p>
<p>语法1：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">range</span>(num)</span><br></pre></td></tr></table></figure></div>
<p>可以获取一个从0开始，到num结束的数字序列（不含num本身）</p>
<p>比如range（5）取得的数据是： [0,1,2,3,4,]</p>
<p>语法2：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">range</span>(num1,num2)</span><br></pre></td></tr></table></figure></div>
<p>获得一个从num1开始，到num2结束的数字序列（不包含num2本身）</p>
<p>语法3：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">range</span>(num1,num2,step)</span><br></pre></td></tr></table></figure></div>

<p>获得一个从num1开始，到num2结束的数字序列（不包含num2本身），并且数字之间的步长以step为准。（step默认是1）</p>
<p>大多数的range序列都是配合for循环使用的</p>
<h2 id="2-3-变量作用域"><a href="#2-3-变量作用域" class="headerlink" title="2.3 变量作用域"></a>2.3 变量作用域</h2><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure></div>
<p>这样子的写法：</p>
<ul>
<li>规范上：不允许</li>
<li>实际上：允许</li>
</ul>
<p>for循环创建的临时变量的作用范围只在for循环的内部， <strong>也就是作用域就在循环体内</strong>，不应该在for循环外部生效（不是不可能）。实际上是可以访问到的，但是在编程的规范上是不允许、不建议这么做。可以在for循环之前就定义好i。</p>
<h2 id="2-4-for循环的嵌套"><a href="#2-4-for循环的嵌套" class="headerlink" title="2.4 for循环的嵌套"></a>2.4 for循环的嵌套</h2><p>语法格式和while嵌套循环一样的。</p>
<p>关键点就是注意好<strong>空格缩进</strong>就行了</p>
<h2 id="3-break和continue关键字"><a href="#3-break和continue关键字" class="headerlink" title="3. break和continue关键字"></a>3. break和continue关键字</h2><p><strong>这两个关键字的用法和c语言中一样</strong></p>
<p>continue：中断本次循环，直接进入下一次循环。可用于for和while循环，效果一致。</p>
<p>注意：</p>
<ul>
<li>如果是在嵌套循环中，continue只能在它所在的循环临时中断。也就是只会中断内部循环，而不会中断外部循环。</li>
</ul>
<p>break： 直接结束循环，可用于for和while循环，效果一致。<br>注意：</p>
<ul>
<li>在嵌套循环中的用法与continue一样。</li>
</ul>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>数据容器</title>
    <url>/2023/07/16/%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="数据容器"><a href="#数据容器" class="headerlink" title="数据容器"></a>数据容器</h1><h2 id="1-数据容器是什么？"><a href="#1-数据容器是什么？" class="headerlink" title="1. 数据容器是什么？"></a>1. 数据容器是什么？</h2><p>程序中如果要记录多个信息，如果一个个去定义变量会非常麻烦。数据容器就是用一个变量，记录多份数据。也就是可以批量存储和批量使用多份数据，类似于数组！</p>
<ul>
<li><p>Python中的数据容器：一种可以<strong>容纳多份数据</strong>的数据类型，容纳的每一份数据称之为一个元素，每一个元素可以是任意类型的数据，比如字符串，数字，bool等等。</p>
</li>
<li><p>数据容器根据特点的不同，比如：</p>
<ul>
<li>是否支持重复元素</li>
<li>是否可以修改</li>
<li>是否有序</li>
<li>等等</li>
</ul>
</li>
</ul>
<p>可以分为五类：列表（list）、元组（tuple）、字符串（str）、集合（set）、字典（dict）。</p>
<h2 id="2-list（列表）"><a href="#2-list（列表）" class="headerlink" title="2. list（列表）"></a>2. list（列表）</h2><h3 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h3><p>基本语法：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#字面量</span></span><br><span class="line">[元素<span class="number">1</span>，元素<span class="number">2</span>，元素<span class="number">3</span>，……]</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义变量</span></span><br><span class="line">变量名称 = [元素<span class="number">1</span>，元素<span class="number">2</span>，元素<span class="number">3</span>，……]</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义空列表</span></span><br><span class="line">变量名称 = []</span><br><span class="line">变量名称 = <span class="built_in">list</span>()</span><br></pre></td></tr></table></figure></div>

<ul>
<li>列表中的每一个数据，称之为元素。元素类型可以为不同的数据类型，而且支持嵌套。</li>
<li>以[]作为标识。</li>
<li>列表内每一个元素之间用逗号隔开。</li>
</ul>
<h3 id="2-2列表的下标索引"><a href="#2-2列表的下标索引" class="headerlink" title="2.2列表的下标索引"></a>2.2列表的下标索引</h3><p>通过下标索引取出列表里面特定位置的数据。</p>
<p>语法：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">列表[下标索引]</span><br></pre></td></tr></table></figure></div>
<p>与c语言不同，列表的下标可以反向索引。比如最后一个元素的下标标记为-1，倒数第二的下标就是-2，以此类推。（就是你直接引用下标是-1的元素，结果就是最后一个元素。）</p>
<p>总之就是说，想取第一个元素，下标就给0，想取最后一个元素，如果在c语言不知道数组长度的话很麻烦，但是Python里面直接下标是-1取出来就是最后一个元素。</p>
<p>列表嵌套的下标索引：</p>
<p>举个例子：</p>
<p>列表[1][0]</p>
<p>意思就是指有一个列表，第二个元素也是列表，先取出这个列表的第二个元素也就是嵌套的列表，然后再取这个内层列表的第一个元素。写法类似于二维数组，但是含义是不一样的。</p>
<ul>
<li>如果下标超出列表本身的大小范围就会报错。</li>
</ul>
<h3 id="2-3列表的常用操作方式"><a href="#2-3列表的常用操作方式" class="headerlink" title="2.3列表的常用操作方式"></a>2.3列表的常用操作方式</h3><p><strong>列表的方法（写在类（class）里面的函数就是方法）</strong>：</p>
<ol>
<li>插入元素</li>
<li>删除元素</li>
<li>清空列表</li>
<li>修改元素</li>
<li>统计元素个数</li>
</ol>
<h4 id="列表的查询功能（方法）"><a href="#列表的查询功能（方法）" class="headerlink" title="列表的查询功能（方法）"></a>列表的查询功能（方法）</h4><ul>
<li>查找某个元素的下标。</li>
</ul>
<p>功能：查找指定元素在列表的下标，如果找不到，报错<strong>ValueError</strong></p>
<p>语法：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">列表.index（元素）</span><br></pre></td></tr></table></figure></div>
<p>index就是列表对象（变量）内置的方法。</p>
<h3 id="列表的修改功能（方法）"><a href="#列表的修改功能（方法）" class="headerlink" title="列表的修改功能（方法）"></a>列表的修改功能（方法）</h3><ul>
<li><p>修改列表中的元素<br>语法：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">列表频[下标] = 值</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>向列表中指定位置插入元素<br>语法：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">列表.insert(下标，元素)</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="追加元素"><a href="#追加元素" class="headerlink" title="追加元素"></a>追加元素</h3><ul>
<li>将指定元素，追加到列表的尾部</li>
</ul>
<p>语法：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">列表.append(元素)</span><br></pre></td></tr></table></figure></div>
<p>如果要追加一批元素：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">列表。extend(其他数据容器)</span><br></pre></td></tr></table></figure></div>
<ul>
<li>将其他数据容器的内容取出，依次追加到列表尾部</li>
</ul>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>语法1：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">del 列表[下标]</span><br></pre></td></tr></table></figure></div>
<p>语法2：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">列表.pop(下标)</span><br></pre></td></tr></table></figure></div>
<p>pop这个方法实际上是取出这个元素，并且返回，所以可以定义一个变量去接收这个被取出来的元素。</p>
<p>语法3：</p>
<ul>
<li>不指定下标，而是指定元素的内容进行删除</li>
<li>从前到后去找这个元素，并且找到的第一个被删掉<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">列表.remove(元素)</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="清空列表"><a href="#清空列表" class="headerlink" title="清空列表"></a>清空列表</h3><p>语法:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">列表.clear()</span><br></pre></td></tr></table></figure></div>
<h3 id="统计某个元素在列表内的数量"><a href="#统计某个元素在列表内的数量" class="headerlink" title="统计某个元素在列表内的数量"></a>统计某个元素在列表内的数量</h3><p>语法：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">count = 列表.count(元素)</span><br></pre></td></tr></table></figure></div>
<h3 id="统计列表中总共有多少个元素"><a href="#统计列表中总共有多少个元素" class="headerlink" title="统计列表中总共有多少个元素"></a>统计列表中总共有多少个元素</h3><p>语法：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">count = len(列表)</span><br></pre></td></tr></table></figure></div>

<h2 id="2-4-列表的特点"><a href="#2-4-列表的特点" class="headerlink" title="2.4 列表的特点"></a>2.4 列表的特点</h2><ul>
<li>列表可以容纳多个元素(上限为2*63-1个)</li>
<li>可以容纳不同类型的元素(混装)</li>
<li>数据是有序存储的(有下标序号)</li>
<li>允许重复数据存在</li>
<li>可以修改(增加或删除元素等等)</li>
</ul>
<h2 id="2-5-列表的遍历"><a href="#2-5-列表的遍历" class="headerlink" title="2.5 列表的遍历"></a>2.5 列表的遍历</h2><ul>
<li><p>将容器内的元素依次取出进行处理的行为，称之为：遍历，迭代。</p>
</li>
<li><p>通过while、for循环来遍历列表的元素。</p>
</li>
</ul>
<p>循环条件如何控制？</p>
<ul>
<li>定义一个变量表示下标，这个变量从0开始。</li>
<li>循环的条件就是 下标值 &lt; 列表的元素数量</li>
</ul>
<p>for与while的区别：  </p>
<ol>
<li>循环控制上</li>
</ol>
<ul>
<li>while循环可以自定义循环条件，自行控制。</li>
<li>for不可以自定义循环条件，只可以一个个从容器内取出数据。</li>
</ul>
<ol start="2">
<li>无限循环上</li>
</ol>
<ul>
<li>while循环可以通过条件控制做到无限循环。</li>
<li>for理论上是不可以实现无限循环，因为遍历的容器容量不是无限的。</li>
</ul>
<ol start="3">
<li>在使用场景上：</li>
</ol>
<ul>
<li>while循环适用于任何想要循环的场景。</li>
<li>for循环适用于遍历数据容器的场景或者简单的固定次数循环的场景。</li>
</ul>
<h2 id="3-元组"><a href="#3-元组" class="headerlink" title="3.元组"></a>3.元组</h2><h3 id="3-1-元组的基本概念与定义"><a href="#3-1-元组的基本概念与定义" class="headerlink" title="3.1 元组的基本概念与定义"></a>3.1 元组的基本概念与定义</h3><p> 有了列表，为什么还需要元组？</p>
<ul>
<li>因为列表是可以修改的，但是如果响应传递的信息，不被修改，列表就不合适了。</li>
</ul>
<p><strong>元组一旦定义完成，就不可修改。可以认为元组就是一个只读的list</strong></p>
<p>所以元组应用于我们需要在程序内封装数据，但是又不希望数据被篡改。</p>
<p>定义语法：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 定义元组字面量</span><br><span class="line">(元素，元素，元素，……)</span><br><span class="line"></span><br><span class="line"># 定义元组变量</span><br><span class="line"></span><br><span class="line">变量名称 = (元素，元素，元素，……)</span><br><span class="line"></span><br><span class="line"># 定义空元组</span><br><span class="line"></span><br><span class="line">变量名称= ()</span><br><span class="line"></span><br><span class="line">变量名称 = tuple()</span><br></pre></td></tr></table></figure></div>

<p>注意事项：</p>
<ul>
<li><strong>如果元组只有一个数据，这个数据后面也要添加括号。否则就不是元组类型了。</strong></li>
<li>元组也可以嵌套(用法参考列表的嵌套)</li>
<li>如果print直接输出元组或者列表的话幂级数把里面的元素都打印出来。（加一个小括号或者中括号。反正就是元组或者列表怎么定义，就怎么打印）</li>
</ul>
<h3 id="3-2-元组的相关操作"><a href="#3-2-元组的相关操作" class="headerlink" title="3.2 元组的相关操作"></a>3.2 元组的相关操作</h3><p>由于元组的不可修改的特性，所以元组的相关操作没有列表那么多。</p>
<p>只有下面三种操作：</p>
<ol>
<li><p>index()方法：查找某个数据，如果数据存在就返回对应的下标，否则报错。</p>
</li>
<li><p>count()方法，统计某个数据在当前元组出现的次数。</p>
</li>
<li><p>len(元组)：统计元组内的元素个数。</p>
</li>
</ol>
<p>特别注意：</p>
<p><strong>元组不可以修改，但是如果元组里面嵌套一个list，这个list是可以修改的！</strong></p>
<h3 id="3-3元组的特点"><a href="#3-3元组的特点" class="headerlink" title="3.3元组的特点"></a>3.3元组的特点</h3><ol>
<li><p>可以容纳多个数据</p>
</li>
<li><p>可以容纳不同类型的数据(混装)</p>
</li>
<li><p>数据是有序存储的(下标索引)</p>
</li>
<li><p>允许重复数据存在</p>
</li>
<li><p><strong>不可以修改</strong>（除非嵌套了list）</p>
</li>
<li><p>支持for循环</p>
</li>
</ol>
<p>（多数特点和list一致。不同点在于不可修改的特性）</p>
<h2 id="4-再识字符串"><a href="#4-再识字符串" class="headerlink" title="4. 再识字符串"></a>4. 再识字符串</h2><p>字符串看上去并不像列表元组那样一看就是存放很多数据的容器。但是不可否认的是，字符串同样也是数据容器的一员。</p>
<p>字符串是字符的容器，一个字符串可以存放任意数量的字符。</p>
<ul>
<li>字符串的下标索引和list、元组是一样的。</li>
<li>和元组一样，字符串是一个<strong>不可修改的数据容器。</strong></li>
</ul>
<p>字符串的方法：</p>
<ol>
<li><p>index()方法</p>
</li>
<li><p>字符串.replace(字符串1，字符串2)。功能：将字符串内的全部：字符串1替换为字符串2。注意这里不是修改字符串本身，老的字符串不变，而是得到一个新的字符串，！</p>
</li>
<li><p>字符串.split(分隔符字符串)。功能：按照指定的分隔符字符串，将字符串划分为多个字符串，并存入列表对象。注意：字符串本身不变，而是得到一个列表对象的。这里的分隔符字符串是你自己定义的，可以是空格，也可以是每一个字符串片段。</p>
</li>
<li><p>字符串.strip。功能：字符串的规整操作，可以去掉前后空格。strip还可以再传入一个字符串作为参数，就可以去掉前后指定的字符串了。注意：如果参数写的是“12”，并不是只找12的字符串去删掉，而是，只要满足其中一个，也就是满足1或者满足2的我都去掉。</p>
</li>
<li><p>字符串.count(“指定的字符串”)方法，功能：统计字符串中指定字符串的出现次数。</p>
</li>
<li><p>len(字符串)。功能：统计字符串的字符个数。</p>
</li>
</ol>
<p>字符串特点：</p>
<ol>
<li><strong>只可以存储字符串</strong></li>
<li>长度任意</li>
<li>支持下标索引</li>
<li>允许重复字符串存在</li>
<li><strong>不可以修改！</strong></li>
<li>支持for循环</li>
</ol>
<h2 id="5-数据容器-序列-的切片操作"><a href="#5-数据容器-序列-的切片操作" class="headerlink" title="5.数据容器(序列)的切片操作"></a>5.数据容器(序列)的切片操作</h2><p>什么是序列？</p>
<ul>
<li>序列是指：内容连续，有序，可以使用下标索引的一类数据容器。列表，元组，字符串均可以视为序列。</li>
</ul>
<p>序列支持切片，也就是：列表，元组，字符串支持切片操作。</p>
<p>切片：从一个序列中，取出一个子序列。</p>
<p>语法：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">序列[起始下标：结束下标：步长]</span><br></pre></td></tr></table></figure></div>

<p>表示：从序列中，从指定位置开始，依次取出元素，到指定位置结束，得到一个新序列。</p>
<ul>
<li><p>起始下标表示从何处开始，可以留空，留空视作从头开始。</p>
</li>
<li><p>结束下标（不含）表示何处结束，可以留空，留空视作截取到结尾。</p>
</li>
<li><p>步长表示，依次取元素间隔。（步长1表示一个个取元素，步长2表示每次跳过一个元素取，步长N表示，每次跳过N-1个元素取。步长为负数表示，反向取（注意，起始下标和结束下标也要方向标记）</p>
</li>
</ul>
<p>注意：</p>
<ul>
<li>切片操作并不会影响序列本身，而是会得到新的序列。（因为元组和字符串都不能修改）</li>
</ul>
<p>写法可以这样子：</p>
<p>1.先倒序字符串再切片取出：</p>
<p>result &#x3D; my_strp[::-1][9:14]</p>
<ol start="2">
<li>先切片取出再倒序：</li>
</ol>
<p>result &#x3D; my_strp[5:10][::-1]</p>
<p>这个字符串的操作可以一连串写下来的。</p>
<p>举个例子：</p>
<p>result &#x3D; my_str(“,”)[1].replace(“来”，””)[::1]</p>
<hr>
<h2 id="6-set-集合"><a href="#6-set-集合" class="headerlink" title="6. set(集合)"></a>6. set(集合)</h2><p>为什么还要集合？<br>列表、元组、字符串都支持元素重复并且有序。</p>
<p>集合最主要的特点就是不支持重复的元素内容，也就是自带去重功能。而且内容是无序的。</p>
<p>定义语法：</p>
<ol>
<li>定义集合字面量<br>{元素，元素，……}</li>
<li>定义集合变量<br>变量名称 &#x3D; {变量，变量，……}</li>
<li>定义空集合<br>变量名称 &#x3D; set()</li>
</ol>
<p>注意：</p>
<ul>
<li><p>定义集合的时候，元素如果有重复的话，运行的话，程序并不会报错，但是重复的内容会自动去重，结果里面就不会重复了。</p>
</li>
<li><p>最后输出显示的时候并不会是定义时候的顺序，所以是乱序的。</p>
</li>
</ul>
<p><strong>因为集合是无序的，所以集合并不支持下标索引访问，集合的下标是没有意义的。所以集合不是序列！</strong></p>
<p><strong>但是集合和列表是一样的，是允许修改的。</strong></p>
<h3 id="集合的常用操作："><a href="#集合的常用操作：" class="headerlink" title="集合的常用操作："></a>集合的常用操作：</h3><ol>
<li><p>添加新的元素 ： 集合.add(元素)。将指定元素，添加到集合内。</p>
</li>
<li><p>移除元素 : 集合.remove(元素)，将指定元素，从集合内移除。</p>
</li>
<li><p>从集合中随机取出元素 ： 集合.pop ，会得到一个元素的结果，同时集合本身被修改，元素被移除。</p>
</li>
<li><p>清空集合 ： 集合.clear() 。</p>
</li>
<li><p>取出两个集合的差集 ： 集合1.difference(集合2) 。功能：取出集合1有但是集合2没有的，得到一个新的集合，集合1和集合2不变。</p>
</li>
<li><p>消除两个集合的差集 ： 集合1.difference_update(集合2) ，功能：在集合1内，删除和集合2相同的元素。结果：集合1被修改，集合2不变。</p>
</li>
<li><p>两个集合合并 ， 集合1.union(集合2) ，功能：将集合1和集合2组合得到新的集合。 结果： 得到新集合，集合1和集合2不变。</p>
</li>
<li><p>统计集合元素数量 ， len(集合)。如果元素重复了，按去重以后的数量计算得到结果。</p>
</li>
<li><p>因为集合不支持下标索引，所以不能用while循环！只能用for循环。</p>
</li>
</ol>
<h2 id="7-dict-字典"><a href="#7-dict-字典" class="headerlink" title="7.dict(字典)"></a>7.dict(字典)</h2><p>类比于生活中的字典，生活中的字典通过’字’找到对应的‘含义’。</p>
<p><strong>Python通过Key找到对应的Value</strong></p>
<p>字典的定义： </p>
<ol>
<li>定义字典字面量</li>
</ol>
<p>{key:value,key:value,……}</p>
<ol start="2">
<li><p>定义字典变量<br>my_dick &#x3D; {key：value,key:value,……}</p>
</li>
<li><p>定义空字典<br>my_dick &#x3D; {}<br>my_dick &#x3D; dick()</p>
</li>
</ol>
<p>字典的定义同样**使用{}**，不过存储的元素是一个个的： <strong>键值对</strong></p>
<ul>
<li><p>Key肯定是不能重复的！因为要通过Key找到value，如果有两个一样的Key，那么用的是哪个value就不知道了。如果两个Key一样，代码不会报错，而是后面的Key的value会覆盖前面那个相同的key的value。</p>
</li>
<li><p>字典是通过key取得对应的value，所以，字典和集合一样，不可以使用下标索引。</p>
</li>
</ul>
<p>使用上来说：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">字典[key] </span><br></pre></td></tr></table></figure></div>
<p>就可以得到对应的value</p>
<ul>
<li><p>字典的key和value可以是任意的数据类型，除了key不能是字典！</p>
</li>
<li><p>字典也是可以嵌套的。比如姓名作为key，考试成绩作为value，但是考试成绩有好几个科目啊，所以value也是可以作为字典。然后value作为字典，里面的key是语文数学等等科目，然后value是成绩。</p>
</li>
<li><p>从嵌套的字典里面取出value的写法也是类似于二维数组那个样子的。比如：字典[“陈鸣”][“语文”]，取出来就是陈鸣的语文成绩。</p>
</li>
</ul>
<h3 id="字典的常用操作"><a href="#字典的常用操作" class="headerlink" title="字典的常用操作"></a>字典的常用操作</h3><ol>
<li><p>新增元素:字典[key] &#x3D; Value ,结果：字典被修改，新增了元素</p>
</li>
<li><p>更新元素： 字典[key] &#x3D; value ，结果：字典被修改，元素被更新。</p>
</li>
</ol>
<p>注意 ：</p>
<ul>
<li>字典的key不可以重复，所以对已经存在的key执行上述操作，就是更新value值。</li>
<li>如果是嵌套字典，可以直接把第一层的字典所包含的内容先赋值给一个新字典（相当于复制一份新的字典）。然后在这个新的字典上修改信息，最后再反向新的字典直接赋值给第一层字典。（虽然绕了点，但是告诉我们可以直接拿字典作为一个整体直接赋值过去）。<br>具体可以看<a class="link"   href="https://www.bilibili.com/video/BV1qW4y1a7fU?t=454.2&p=77" >黑马的Python <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
<ol start="3">
<li><p>删除元素：字典pop(key) ，结果：会返回这个value，然后字典中的这个key和value都会被删除。</p>
</li>
<li><p>清空元素 ：字典.clear</p>
</li>
<li><p>获取全部key ：字典.keys() ,结果：获取字典中的全部key</p>
</li>
<li><p>统计字典的元素数量 ： len(字典) </p>
</li>
<li><p>获取了全部的key有什么用呢？拿来遍历字典。或者也可以直接对字典进行for循环，每一次循环但是直接得到key。</p>
</li>
<li><p>字典不支持下标索引，所以不能用while循环。</p>
</li>
</ol>
<h2 id="8-数据容器对比总结"><a href="#8-数据容器对比总结" class="headerlink" title="8. 数据容器对比总结"></a>8. 数据容器对比总结</h2><p>简单的分类：</p>
<ul>
<li><p>是否支持下标索引：</p>
<ul>
<li>支持：列表，元组，字符串 —序列类型</li>
<li>不支持：集合，字典 —非序列类型</li>
</ul>
</li>
<li><p>是否支持重复元素：</p>
<ul>
<li>支持：列表，元组，字符串 —序列类型</li>
<li>不支持：集合，字典 —非序列类型</li>
</ul>
</li>
<li><p>是否可以修改</p>
<ul>
<li>支持：列表，集合，字典<br>  不支持：元组，字符串</li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64ba71681ddac507cc25e216.jpg"
                      alt="Alt text"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64ba74681ddac507cc3134ed.jpg"
                      alt="Alt text"
                ></p>
<h2 id="9-数据容器的通用操作"><a href="#9-数据容器的通用操作" class="headerlink" title="9. 数据容器的通用操作"></a>9. 数据容器的通用操作</h2><p>数据容器尽管各有各的特点，但是它们也有通用的操作：</p>
<ol>
<li>遍历：</li>
</ol>
<ul>
<li>5类数据容器都支持for循环遍历。</li>
<li>列表，元组，字符串支持while循环。集合，字典不支持(无法下标索引)</li>
</ul>
<p>尽管遍历的形式各有不同，但是，他们都支持遍历。</p>
<ol start="2">
<li>通用的功能方法：</li>
</ol>
<ul>
<li>len(容器)  统计容器的元素个数</li>
<li>max(容器)  统计容器的最大元素</li>
<li>min(容器)  统计容器的最新元素</li>
</ul>
<p>（快捷键： shift + alt + 拖动鼠标 ，可以按列选中）</p>
<ol start="3">
<li>容器的通用转换功能：</li>
</ol>
<p>转换的格式个之前学的数据类型的转换格式是一样的。</p>
<p>比如:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">list(容器)</span><br></pre></td></tr></table></figure></div>
<p>将给定的容器转换为列表。注意字符串转列表，是把字符串的每一个字符拿出来当做列表的每一个元素。字典转列表，列表中只存放字典的key。转元组同理。</p>
<p>其他类型转字符串的话，所有元素都可以保留。</p>
<p>转集合的话，记住会乱序并且去重。<br>字典转集合同样也是舍去了value，只留下了key。</p>
<p>能不能转字典？有这个转换函数，但是字典要的是键值对，所以有函数，但是你转不了。</p>
<ol start="4">
<li>容器通用排序功能：<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sorted(容器，[reverse=True])</span><br></pre></td></tr></table></figure></div>
reverse默认是false,如果想要想要排序进行反转，那就第二个参数写一个reverse &#x3D; True进去进行了。否则就不写就是默认参数。</li>
</ol>
<p>注意：</p>
<ul>
<li>排序以后的结果都是列表对象！实际上就是对内容进行排序然后放到列表中。所以对字典进行排序，结果只有key，没有value了</li>
</ul>
<h2 id="10-拓展：字符串比大小"><a href="#10-拓展：字符串比大小" class="headerlink" title="10. 拓展：字符串比大小"></a>10. 拓展：字符串比大小</h2><p>字符串比较是基于数字的码值大小进行比较的(码值就是ASCII码表里面对应的值)</p>
<p><strong>字符串是按位比较，也就是一位位进行对比，只要有一位大，那么整体就大。</strong></p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>格式化的精确控制 &amp; 数据输入（input语句）</title>
    <url>/2023/07/14/%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%9A%84%E7%B2%BE%E7%A1%AE%E6%8E%A7%E5%88%B6%20&amp;%20%E6%95%B0%E6%8D%AE%E8%BE%93%E5%85%A5%EF%BC%88input%E8%AF%AD%E5%8F%A5%EF%BC%89/</url>
    <content><![CDATA[<h1 id="格式化的精度控制"><a href="#格式化的精度控制" class="headerlink" title="格式化的精度控制"></a>格式化的精度控制</h1><p>使用m.n控制数据的宽度和精度。<br>m，控制宽度，要求是数字（很少用），如果设置的宽度小于数字自身，不生效。<br>.n，控制小数点精度，要求是数字，<strong>会进行小数的四舍五入，数据会失真</strong></p>
<h2 id="字符串快速格式化"><a href="#字符串快速格式化" class="headerlink" title="字符串快速格式化"></a>字符串快速格式化</h2><p>语法：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">f&quot;内容&#123;变量&#125;&quot;</span><br></pre></td></tr></table></figure></div>

<p> 此时的变量不限制数据类型，不会进行进度控制，会原样输出。这里的大括号就是占位符。</p>
<p>比如：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;qiemi&quot;</span></span><br><span class="line">age = <span class="number">18</span></span><br><span class="line">printf(<span class="string">f&quot;我是<span class="subst">&#123;name&#125;</span>,我今年<span class="subst">&#123;age&#125;</span>岁了&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<p>特点：</p>
<ol>
<li><p>不理会类型（类似于c++的cout）</p>
</li>
<li><p>不做精度控制（适合对精度没有要求的时候快速使用）</p>
</li>
</ol>
<h2 id="对表达式格式化"><a href="#对表达式格式化" class="headerlink" title="对表达式格式化"></a>对表达式格式化</h2><p>首先，什么是表达式？</p>
<p>表达式：一条具有<strong>明确执行结果</strong>的<strong>代码语句</strong>。<br>比如“</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1+1</span><br><span class="line">2*2</span><br><span class="line">name = &quot;qiemi&quot;</span><br><span class="line">age = 19</span><br></pre></td></tr></table></figure></div>


<p>表达式的格式化：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;1+1的结果是： %d&quot;</span> %(<span class="number">1</span>+<span class="number">1</span>)) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;9*9的结果是： <span class="subst">&#123;<span class="number">9</span>*<span class="number">9</span>&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;字符串在Python里面的的类型是 ：%s&quot;</span> % <span class="built_in">type</span>(<span class="string">&#x27;字符串&#x27;</span>))</span><br></pre></td></tr></table></figure></div>

<p>适合在不需要变量进行数据存储的时候，可以直接格式化表达式，简化代码。</p>
<h1 id="数据输入（input语句）"><a href="#数据输入（input语句）" class="headerlink" title="数据输入（input语句）"></a>数据输入（input语句）</h1><p>语法：<br>使用一个变量接收（存储）input语句获取的键盘输入数据即可</p>
<p>比如：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;请输入你的名字&quot;</span>)</span><br><span class="line">name = <span class="built_in">input</span>();</span><br></pre></td></tr></table></figure></div>
<p>上述例子的print其实是多余的，因为input语句自身就可以输出提示内容。所以可以进行简化：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="built_in">input</span>(<span class="string">&quot;请输入你的名字&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<p><strong>！！！input语句不管你写入的是什么数据，默认统统当做字符串看待！！！所以记得进行对应的数据类型转换</strong></p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>pid控制算法</title>
    <url>/2023/07/18/pid%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="PID"><a href="#PID" class="headerlink" title="PID"></a>PID</h1><ol>
<li>介绍pid</li>
</ol>
<ul>
<li>引言：如果不用PID算法，想要让小车前进100米，那就要得到小车的速度，然后100&#x2F;v得到小车前进的时间，然后让小车在这段时间内一直前进就好了。<br>这种控制叫做开放回路控制系统。因为机器人的输出(也就是机器人的位置)并不会发过来影响机器人的输入(也就是电机的转动)。</li>
</ul>
<p>这种方式在要求不高的场合是可以的。但是如果小车在运动过程中发生了偏移，或者前进的路面是不平坦的，又或者是机器人的速度慢了一点点，那么机器人就永远达到不了预期的100米位置。</p>
<p>因此在这种情况下，我们更加需要的是一种，闭环的控制系统。也就是输出会返回来影响输入，也就是引入反馈，利用反馈，去弥补干扰，比如说干扰让输出减小了1，反馈就让输出再多1。PID是闭环控制的一种，pid也是应用最为广泛的一种。</p>
<ol start="2">
<li>闭环控制系统<br>（pid适合于二阶以内的线性系统：满足齐次性和叠加性）<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64ba71961ddac507cc2699f7.jpg"
                     
                ></li>
</ol>
<ul>
<li>单闭环：引入了闭环控制系统，信号的输入在输入到控制器之前会先进行因此运算，E(误差，也就是净输入) &#x3D; X(输入) - Y(反馈) ，然后控制器计算得到控制信号Uc，给到执行器，执行器作用到对象，对象再输出Y反馈回去。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64ba71f41ddac507cc27fd74.jpg"
                      alt="Alt text"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64ba72161ddac507cc288167.jpg"
                      alt="Alt text"
                ></p>
<ul>
<li>双闭环 ：内层的环相当于可以控制管道内的流量变化不会剧烈变化。</li>
</ul>
<ol start="3">
<li>参数详解</li>
</ol>
<ul>
<li>误差：输入减去输出，也就是净输入。</li>
<li>控制器输出：将误差经过运算，得到需要执行器执行的量。（可以理解为水阀需要扭多少角度）</li>
<li>执行器输出：接收到了控制器输出以后，执行器做出对应的输出。（可以理解为水阀打开的开口的大小）</li>
<li>系统输出：就是最后对象的输出，实际的输出，可以理解为最后输出的水流量。</li>
</ul>
<ol start="4">
<li>pid公式</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64ba72381ddac507cc28ff1b.jpg"
                      alt="Alt text"
                ><br>C是输出，e是误差，也就是净输入。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64ba72451ddac507cc292f73.jpg"
                      alt="Alt text"
                ><br>最后就是用下面那个公式去实现pid的。<br>控制器的输出就等于kp乘以误差 + ki乘以误差的累积 + kd乘以误差的变化值。</p>
<ol start="5">
<li>形象解释PID各个参数的含义<br>举个例子:</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64ba72581ddac507cc297874.jpg"
                      alt="Alt text"
                ><br>在这种单p控制时候下的位置和速度的变化如下图：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64ba726b1ddac507cc29bc16.jpg"
                      alt="Alt text"
                ><br><strong>P值越大，速度越大，到达期望的时间越短。</strong></p>
<p>再举个例子：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64ba72861ddac507cc2a19ee.jpg"
                      alt="Alt text"
                ><br>假设无人机的航模电机的转速达到100转&#x2F;分钟的时候才会和无人机自身重力平衡，无人机就达到悬停。</p>
<p>那么如果无人机一开始在地面上，实际高度是0，然后P是1，那么P<em>误差，刚刚好就是100，所以无人机在地面无法起飞。如果P等于2，那么无人机起飞到50m的时候，P</em>误差又等于100了，无人机就悬停在了50m的位置。如果P给100，无人机就会悬停在99米的位置。如果P给1000，无人机就悬停在了99.9米的位置。</p>
<ul>
<li>可见，用于无人机自身的重力的存在，所以无人机想要达到目标高度是和小车不一样的，如果只靠P的话，只能无限接近期望高度，是永远也达不到期望高度的。</li>
</ul>
<p>所以就要引入I，假设现在无人机飞到了99米，距离期望高度还有1m，但是无人机悬停了，不能往上再飞了，这个1m就叫做<strong>稳态误差</strong>。稳态误差一般就是用I弥补的。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64ba729c1ddac507cc2a66b7.jpg"
                      alt="Alt text"
                ><br>P设定完了就不变了，到达99米的时候，由P产生的升力只够维持无人机悬停了。积分I是根据以往的误差积累的，那么现在的误差是不变的，I就会一直线性增加，那么I加上P就产生一个新的升力，然后无人机就可以继续上升，理想情况下无人机就可以达到理想高度。</p>
<p>那么现在达到目标高度了，误差等于0了，由P产生的升力也等于0了。<br>升力由积分项提供，积分不受当前状态的影响，只受以前所有误差的积累的影响。所以积分项不会因为现在的误差变成0而变了。他只是不再积累了。但是积分项不是0哦！所以此时悬停的工作就给了I。</p>
<p>那现在来说D！如果P一开始是100，误差一开始也是100.那么一开始的升力就达到了10000，太大了。积分项从100一直积分下去也是挺大的。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64ba73161ddac507cc2c2474.jpg"
                      alt="Alt text"
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64ba732b1ddac507cc2c6e7b.jpg"
                      alt="Alt text"
                ><br>也就是P和I在一开始的时候会非常大。<br>无人机就会直接冲过100米，可能飞到150米然后再飞回来……<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64ba733b1ddac507cc2cdce1.jpg"
                      alt="Alt text"
                ><br>比如这样子。</p>
<p>所以就要引入微分。微分就是对误差进行求导。导数值就是微分项。一开始PI都是正的，导致E误差是在下降的，所以对误差求导得到的D就是负的，所以D就可以去抵消PI。</p>
<ol start="6">
<li>调参</li>
</ol>
<p>慢慢调大Kp，直到差不多达到期望高度。然后加入Ki，Ki小一点消除误差效果就差一点反之……发现有超调现象就调大Kd，但是如果Kd太大了会严重影响系统的调节时间，让系统调节时间很长。</p>
<ul>
<li>调大Kp直到接近期望高度。</li>
<li>加入Ki，先给小，然后慢慢加大。然后就接近贴合了。</li>
<li>但是有时候对于时间有要求的，所以Ki继续给大，就会出现超调了。一般来说引入PI就可以了，如果超调，震荡很明显就引入Kd。</li>
</ul>
<ol start="7">
<li>其余相关控制知识</li>
</ol>
<ul>
<li>积分限幅：假设现在有人在无人机起飞的时候一直按着无人机，那么无人机无法起飞，误差一直是100，积分I就一直积分一直积分，积分到很大。然后这个人突然放手，此时不仅有一个很大的I，P也参与进来，此时升力就非常非常非常大，无人机就会一飞冲天了。所以就要给积分项一个限制，积分项升到多大的时候就不能再升了。</li>
<li>积分分离：比如现在飞机悬停在了100m了，只靠着I产生的升力悬停。如果突然修改期望高度到1000m，那么误差项就会突变，然后积分项也会随着突然增大很多。也会导致超调。所以可以引入一个判断，如果误差大于某个值的时候，就让积分项等于0，先不用积分项，然后单单只靠P，来把误差变小，然后误差小于一定值再引入I。</li>
<li>微分先行：不再是让误差直接传给D，而是输出通过传感器传给D，这样子如果期望高度突变，影响是先给到P和I，不会马上给D，这样子就消除了输入突变的影响。</li>
</ul>
<ol start="8">
<li>理论到实际<br>示例1：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64ba73531ddac507cc2d33ea.jpg"
                      alt="Alt text"
                ><br>控制器就是根据PID的那个公式算得的结果，然后根据CAN协议传给执行器，也就是电调。然后电调给对应的电机电流，然后电机的输出（可以是电机的转速）反馈回去再进行一次pid控制。</li>
</ol>
<p>代码讲解：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64ba73601ddac507cc2d631a.jpg"
                      alt="Alt text"
                ><br>首先还要定义一下我们的期望输出：</p>
<ul>
<li>………….speedPID.target &#x3D; 500; &#x2F;&#x2F;期望输出是电机没秒500转</li>
</ul>
<p>然后代码第一行就是获取现在的转速，也就是反馈量。从电机发回来的数据包里面拿到这个转速。<br>然后调用pid_calc这个函数，函数的定义在下面。</p>
<ul>
<li>这个算法的第一句就是输入减去输出得到误差值，也就是净输入。</li>
</ul>
<p>然后要把这个误差值给到控制器。</p>
<ul>
<li>就是第二句就是把算出来的误差e去乘以比例Kp。</li>
<li>第三句就是累加积分。</li>
<li>else语句下面的第一句就是计算D</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64ba73721ddac507cc2da27d.jpg"
                      alt="Alt text"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64ba73801ddac507cc2dd4b6.jpg"
                      alt="Alt text"
                ><br>P,I,D都算出来了，根据公式或者是流程图，得把他们加起来了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64ba738e1ddac507cc2e09ae.jpg"
                      alt="Alt text"
                ><br>所以这里就是在求和。</p>
<ul>
<li><p>还有积分限幅和积分分离，这两个都标记了注释，很好理解。</p>
</li>
<li><p>最后的的输出限幅是最后的安全保障。</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64ba739e1ddac507cc2e440b.jpg"
                      alt="Alt text"
                ><br>特别注意！代码只是演示。实际上使用，这两部分用一个就行了，如果两个都写进去就一次循环里面积分了两次！是错误的。</p>
<p>如果既想要积分限幅又想要积分分离，那就把第三句的积分去掉，只留下积分分离里面的积分就好了。然后再把积分限幅放到积分分离的累加积分的那一句的下面就行了。</p>
<p>最后经过公式，求和以后得到的pid_total就是给到执行器的数据。然后执行器执行到对象，然后对象再输出一个反馈量回去。</p>
<p>示例2：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64ba73aa1ddac507cc2e6d8a.jpg"
                      alt="Alt text"
                ><br><a class="link"   href="https://www.bilibili.com/video/BV1B54y1V7hp?t=855.8&p=5" >点我，看具体细节 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64ba73bf1ddac507cc2eb948.jpg"
                      alt="Alt text"
                ></p>
]]></content>
      <tags>
        <tag>PID</tag>
      </tags>
  </entry>
  <entry>
    <title>指针的详解与应用</title>
    <url>/2023/07/19/%E6%8C%87%E9%92%88%E7%9A%84%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>指针(poiner)是c语言的重要知识点，其使用灵活，功能强大，是c语言的灵魂。</p>
<p>指针与底层硬件联系紧密，使用指针可以操作数据的地址，实现数据的间接访问。</p>
<h2 id="1-计算机的存储机制"><a href="#1-计算机的存储机制" class="headerlink" title="1. 计算机的存储机制"></a>1. 计算机的存储机制</h2><p>int a &#x3D; 0x12345678</p>
<p>因为一个地址下面<strong>只能放一个字节</strong>的数据，a超过了一个字节，就会拆分掉去存放，现在大多数的计算机的存储方式都是<strong>小端存储</strong>，意思就是说拆出来的最低的俩位，0x78，放在地址的开头，然后从这个地址往下，依次存放剩下的0x56,0x34……</p>
<p>（每个十六进制占0.5个字节，0x00表示一个字节）</p>
<h2 id="2-定义指针"><a href="#2-定义指针" class="headerlink" title="2. 定义指针"></a>2. 定义指针</h2><ul>
<li>指针即指针变量，本身也是一种变量。用于存放其他数据单元（变量&#x2F;数组&#x2F;结构体&#x2F;函数等）的首地址。若指针存放了某个数据单元的首地址，则这个指针指向了这个数据单元，若指针存放的值是0，则这个指针是空指针。</li>
</ul>
<p>定义语法：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据类型 * 指针变量名称 = 被指向的变量名称;</span><br></pre></td></tr></table></figure></div>

<p>不同于不同数据类型所定义出来的变量所占的字节数不同，指针变量的所占的字节数并不取决于定义指针时的数据类型。而是取决于操作系统：<br>16位操作系统 ：2字节， 32位操作系统 ：4字节， 64位操作系统 ：8字节。</p>
<h2 id="3-指针的操作"><a href="#3-指针的操作" class="headerlink" title="3. 指针的操作"></a>3. 指针的操作</h2><ul>
<li>取地址 ：p &#x3D; &amp;a; 将数据a的首地址赋值给p。</li>
<li>取内容 ： *p; 取出指针指向的数据单元。</li>
<li>加 ： p++; 使指针向下移动一个数据宽度（数据宽度就是定义指针的时候的前面的那个数据类型）。</li>
<li>减 ： p–; 使指针向上移动一个数据宽度。<br>（加减一般用于数组，否则一般的加减没有意义。）</li>
</ul>
<h2 id="4-数组与指针"><a href="#4-数组与指针" class="headerlink" title="4. 数组与指针"></a>4. 数组与指针</h2><ul>
<li>数组是一些相同数据类型的变量组成的几何，其数组名就是指向该数据类型的指针。数组的定义等效于申请内存，定义指针和初始化。利用数组下标引用数组数据也等效于指针取内容。（可以说：数组就是指针，二者是一样的。<strong>你可以直接拿数组名当做指针来用</strong>，数组名++之类的。）</li>
</ul>
<p>注意事项：  </p>
<ul>
<li>在对指针取内容之前，一定要确保指针指在合法的位置，否则将导致程序出现不可预知的错误。</li>
<li>同级指针之间才能相互赋值，跨级赋值会导致编译器报错或警告。因为指针再取地址就得到二级指针，变量取地址可以赋值给指针，但是不能跨级赋值给二级指针，同样的，指针取内容可以赋值给变量，而不能直接把指针赋值给变量，这样子也是跨级，得先强制类型转换才可以赋值给变量。</li>
</ul>
<h2 id="5-指针的应用"><a href="#5-指针的应用" class="headerlink" title="5. 指针的应用"></a>5. 指针的应用</h2><h3 id="5-1-传递参数"><a href="#5-1-传递参数" class="headerlink" title="5.1 传递参数"></a>5.1 传递参数</h3><ul>
<li><p>使用指针传递大容量的参数，主函数和子函数使用的是同一套数据，避免了参数传递过程中的数据复制，提高了运行效率，减少了内存占用。</p>
</li>
<li><p>使用指针传递输出参数，利用主函数和子函数使用同一套数据的特性，实现数据的返回，可实现多返回值函数的设计。</p>
</li>
</ul>
<h3 id="5-2-传递返回值"><a href="#5-2-传递返回值" class="headerlink" title="5.2 传递返回值"></a>5.2 传递返回值</h3><ul>
<li>将模块内的公有部分返回，让主函数持有模块的“句柄”，便于程序对指定对象的操作。（句柄就是把手的意思，只要有一个把手就可以操作。可以认为是指针）<br><a class="link"   href="https://www.bilibili.com/video/BV1Mb4y1X7dz?t=5335.6" >详细示例 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
<h3 id="5-3-直接访问物理地址下的数据（单片机中的应用）"><a href="#5-3-直接访问物理地址下的数据（单片机中的应用）" class="headerlink" title="5.3 直接访问物理地址下的数据（单片机中的应用）"></a>5.3 直接访问物理地址下的数据（单片机中的应用）</h3><ul>
<li>访问硬件指定内存下的数据，比如设备ID号等</li>
<li>将复杂格式的数据转换为字节，方便通信与存储。</li>
</ul>
<p><a class="link"   href="https://www.bilibili.com/video/BV1Mb4y1X7dz?t=6129.1" >详细示例 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>最后一段的内容有点东西，实现了把char型指针转化为float型指针的过程。实现了传递一个float类型的数据。</p>
<p>原理：float类型的数据手机的存储其实是：最高位是符号位，然后有一段是阶码，就是多少次方，科学计数法嘛。然后还有一段是尾码，就是科学计数法的x.x的数字。所以float类型可以存储很大的数字，但是进度有问题。</p>
<p>但是发送数据出去，都是以字节为单位发送的，（我认为不可以直接定义float的指针去作为函数的参数去发送float数据）怎么办？那就定义一个unsigned char 的指针，用这个指针去指向这个float的数据(float的数据要先取地址再强制类型转换)，这样子就把这个float的所有字节数据都发过去了。然后接收的时候再定义一个float的指针去把数据取出来，相当于进行了解码。</p>
<ul>
<li>存储器都是以字节为单位进行存储，所以都可以用一个unsigned char *去存储。读的时候再强制类型转换为相应类型的指针。就可以把所有复杂格式的数据转换为字节来通信和存储，这种复杂格式包括：结构体，float，double等等。总之就当做字节来看就可以存储了。</li>
</ul>
]]></content>
      <tags>
        <tag>C语言 指针的详解与应用</tag>
      </tags>
  </entry>
  <entry>
    <title>函数进阶</title>
    <url>/2023/07/21/%E5%87%BD%E6%95%B02-0/</url>
    <content><![CDATA[<h1 id="函数进阶"><a href="#函数进阶" class="headerlink" title="函数进阶"></a>函数进阶</h1><h2 id="1-函数多返回值"><a href="#1-函数多返回值" class="headerlink" title="1.函数多返回值"></a>1.函数多返回值</h2><p>语法：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">def test_return():</span><br><span class="line">    return 1,2</span><br><span class="line"></span><br><span class="line">x,y = test_return()</span><br></pre></td></tr></table></figure></div>
<ul>
<li>与c语言不同。Python可以按照返回值的顺序，写对应顺序的多个变量接收即可。变量之间用逗号隔开。支持不同类型的数据return。</li>
</ul>
<h2 id="2-函数多种传参方式"><a href="#2-函数多种传参方式" class="headerlink" title="2. 函数多种传参方式"></a>2. 函数多种传参方式</h2><h3 id="2-1-位置参数"><a href="#2-1-位置参数" class="headerlink" title="2.1 位置参数"></a>2.1 位置参数</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64ba751d1ddac507cc33b7ce.jpg"
                     
                ><br>这个就是我们之前一直学的东西。</p>
<h3 id="2-2-关键字参数"><a href="#2-2-关键字参数" class="headerlink" title="2.2 关键字参数"></a>2.2 关键字参数</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64ba75c01ddac507cc3602cd.jpg"
                     
                ></p>
<p> 就是在传参的时候指定好形式参数的名字。</p>
<ul>
<li>混用的时候，如果位置参数放在后面，就会报错。</li>
</ul>
<h3 id="2-3-缺省参数"><a href="#2-3-缺省参数" class="headerlink" title="2.3 缺省参数"></a>2.3 缺省参数</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64ba77821ddac507cc3c1f31.jpg"
                     
                ></p>
<p>就是相当于默认参数</p>
<ul>
<li>默认参数必须放在最后，放在前面会报错。</li>
</ul>
<h3 id="2-4-不定长参数"><a href="#2-4-不定长参数" class="headerlink" title="2.4 不定长参数"></a>2.4 不定长参数</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64ba78021ddac507cc3dc166.jpg"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64ba78461ddac507cc3ea8fe.jpg"
                     
                ></p>
<ul>
<li>位置参数的不定长，就是说参数的个数可以是任意的。</li>
<li>参数那边必须加一个*号标志一下。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64ba79031ddac507cc415611.jpg"
                     
                ></p>
<ul>
<li>关键字传递的不定长要两个*号。</li>
<li>出入的参数的书写格式必须是键值对</li>
<li>传递进去的参数就会作为一个字典存在。相当于**kwaargs就是一个字典对象了。（kwargs也就是 key - words）</li>
</ul>
<h2 id="2-3-函数作为参数传递"><a href="#2-3-函数作为参数传递" class="headerlink" title="2.3 函数作为参数传递"></a>2.3 函数作为参数传递</h2><p>之前的参数都是数据。</p>
<p>现在就是把函数本身作为一个参数传入另外一个函数。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64ba7b7e1ddac507cc494e16.jpg"
                     
                ></p>
<ul>
<li><p>这其实是计算逻辑的传递，而不是数据的传递。任何逻辑都可以自行定义并且作为函数传入。函数作为参数传入的本质是传入这个函数的代码逻辑。</p>
</li>
<li><p>普通的数据传入是，逻辑已经确定了，只是数据不确定。函数作为数据传入，它指的是计算的数据已经确定，但是计算数据的逻辑是不确定的。</p>
</li>
<li><p>函数传入的作用：1. 传入计算逻辑，而非传入数据。<br><strong>- 个人总结：这里和以前学过的在一个函数中调用另外一个函数是不一样的！！！！因为函数作为参数了，你传入不同的函数进去，数据已经定死了，但是执行的逻辑就变了。记住这里的compute是你传入的函数的别名，传入不同的函数，compute就不同！！</strong></p>
</li>
</ul>
<h2 id="2-4-lambda匿名函数"><a href="#2-4-lambda匿名函数" class="headerlink" title="2.4 lambda匿名函数"></a>2.4 lambda匿名函数</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64ba7f791ddac507cc57089b.jpg"
                     
                ></p>
<ul>
<li>函数体只能写一行！！不能写多行</li>
<li>lambda是不写return语句的，默认是直接return的。</li>
</ul>
<p>示例：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64ba80c91ddac507cc5c1fec.jpg"
                     
                ></p>
<ul>
<li>匿名函数不能重复使用，有什么用呢？只是如果你的函数的代码只有一行，这时候，为了简单，就不用再去重新定义一个函数了。（真实应用中还是很常用的）</li>
</ul>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>四元数</title>
    <url>/2023/07/21/%E5%9B%9B%E5%85%83%E6%95%B0/</url>
    <content><![CDATA[<h1 id="四元数"><a href="#四元数" class="headerlink" title="四元数"></a>四元数</h1><p>作为做飞控的，想要控制好无人机的姿态，四元数是必须学习的。</p>
]]></content>
      <tags>
        <tag>AC_fly飞控</tag>
      </tags>
  </entry>
  <entry>
    <title>文件操作</title>
    <url>/2023/07/22/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><h2 id="1-文件的编码"><a href="#1-文件的编码" class="headerlink" title="1. 文件的编码"></a>1. 文件的编码</h2><ul>
<li>计算机只认识0和1。我们使用编码技术（密码本）将内容翻译成0和1存入。</li>
</ul>
<p><strong>编码技术就是：翻译的规则。记录了如何将内容翻译成二进制，以及如何将二进制翻译回可识别内容。</strong></p>
<ul>
<li><p>计算机有许多可用编码：<strong>UTF-8</strong>、GBK、Big5等等。（UTF-8是现在全球通用的。）</p>
</li>
<li><p>记录文件的时候用的是什么编码，打开文件的时候也要用同样的编码去打开。</p>
</li>
</ul>
<h2 id="2-文件操作"><a href="#2-文件操作" class="headerlink" title="2. 文件操作"></a>2. 文件操作</h2><p>内存中存放的数据在计算机关闭之后就会消失，要长久保存数据，就要使用硬盘，光盘，U盘等设备，为了便于管理和检索，就引入了“<strong>文件</strong>”的概念</p>
<p>操作系统以文件为单位管理磁盘中的数据。</p>
<ul>
<li>文件操作主要包括：<strong>打开，读写，关闭。</strong></li>
</ul>
<h3 id="2-1打开文件"><a href="#2-1打开文件" class="headerlink" title="2.1打开文件"></a>2.1打开文件</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64bb43d11ddac507cc64e679.jpg"
                     
                ><br>encoding的位置顺序不是第三位。所以如果不使用关键字参数，最后值不会传给encoding。</p>
<p>最后得到的f是对文本文件进行操作的一个对象<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64bb44611ddac507cc6707a4.jpg"
                     
                ></p>
<h3 id="2-2-读操作相关方法"><a href="#2-2-读操作相关方法" class="headerlink" title="2.2 读操作相关方法"></a>2.2 读操作相关方法</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64bb456e1ddac507cc6aa856.jpg"
                     
                ></p>
<ul>
<li><p>单位是字节，如果文件里面的数据是中文。读取10个字节，结果就是得到的10个中文。所以一个中文占1个字节吗？我记得c语言课上老师说，一个中文占的是2个字节？</p>
</li>
<li><p>如果连续调用两次read函数的话，第一次read读取的结尾，程序集会记录当前已经读到这里了。所以下一次调用的时候，从上一次读的结尾继续往下面读。（并且read和readlines是同理的，readlines也会接着从上一个read函数读取到的文件的结尾继续往下读。）</p>
</li>
<li><p>readlines函数的返回值是一个列表。</p>
</li>
<li><p>还有一个readline方法：一次只读取一行内容。</p>
</li>
<li><p>其实吧，read函数就是把文件的内容拿出来，然后我们可以对这些内容进行操作。</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64bb48451ddac507cc74c49b.jpg"
                     
                ></p>
<h3 id="2-3-关闭文件"><a href="#2-3-关闭文件" class="headerlink" title="2.3 关闭文件"></a>2.3 关闭文件</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64bb489a1ddac507cc75e4bd.jpg"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64bb49731ddac507cc7890af.jpg"
                     
                ></p>
<ul>
<li>在那个冒号后面的一大堆语句执行完以后文件就会被自动关闭了。</li>
</ul>
<h3 id="2-4-文件的写入"><a href="#2-4-文件的写入" class="headerlink" title="2.4 文件的写入"></a>2.4 文件的写入</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64bba4001ddac507ccae4939.jpg"
                     
                ></p>
<ul>
<li>如果是写入模式（w模式）的话，文件不存在，会自动帮你创建一个文件。如果文件存在的话，用这个模式会把文件里面的<strong>内容全部清空</strong>，然后写我们想写的东西。</li>
<li>close方法是内置flush方法的。</li>
</ul>
<h3 id="2-5-文件的追加"><a href="#2-5-文件的追加" class="headerlink" title="2.5 文件的追加"></a>2.5 文件的追加</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64bc9e3c1ddac507cc59dfea.jpg"
                     
                ></p>
<ul>
<li>需要换行就用\n</li>
</ul>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>异常</title>
    <url>/2023/07/23/%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="1-了解异常"><a href="#1-了解异常" class="headerlink" title="1.了解异常"></a>1.了解异常</h2><p>异常：当检测到一个错误的时候，Python解释器就无法继续执行了，反而会出现一些错误的提示，这就是所谓的“异常”，也就是我们说的bug。</p>
<h2 id="2-异常的捕获方法"><a href="#2-异常的捕获方法" class="headerlink" title="2. 异常的捕获方法"></a>2. 异常的捕获方法</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64bcc46d1ddac507ccbdfdd0.jpg"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64bcc4bf1ddac507ccbeeefc.jpg"
                     
                ></p>
<h3 id="2-1捕获常规异常"><a href="#2-1捕获常规异常" class="headerlink" title="2.1捕获常规异常"></a>2.1捕获常规异常</h3><ol>
<li><p>基本语法：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    可能发生错误的代码</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    如果出现异常执行的代码</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>进阶语法：捕获指定异常</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line"><span class="keyword">except</span> NameError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;name变量名称为定义错误&#x27;</span>)</span><br></pre></td></tr></table></figure></div></li>
</ol>
<ul>
<li>异常的类型是各种各样的。如果尝试执行的代码的异常类型和要捕获的异常类型不一致，则无法捕获异常。</li>
<li>一般try下方只放一行尝试执行的代码。</li>
<li>这里的e是别名。</li>
</ul>
<ol start="3">
<li>进阶语法：捕获多个异常<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>/<span class="number">0</span>)</span><br><span class="line"><span class="keyword">except</span>(NameError,ZeroDivisionError) <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;出现变量为定义或者除以0异常错误...&#x27;</span>)</span><br></pre></td></tr></table></figure></div></li>
</ol>
<ul>
<li>当捕获多个异常的时候，可以把要捕获的异常类型的名字，放到except后，并且使用元组的方式进行书写。</li>
</ul>
<ol start="4">
<li>捕获所有异常</li>
</ol>
<ul>
<li>其实第一种基本语法就是捕获所有异常了。但是还有一种写法，表示所有异常类型。</li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;出现异常了&#x27;</span>)</span><br></pre></td></tr></table></figure></div>
<ul>
<li>以后一般用这种方式，因为Exception其实是顶级的异常。</li>
</ul>
<h3 id="2-2-异常的else和finally"><a href="#2-2-异常的else和finally" class="headerlink" title="2.2 异常的else和finally"></a>2.2 异常的else和finally</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64bcc9c41ddac507cccdea48.jpg"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64bcc9ed1ddac507ccce6454.jpg"
                     
                ></p>
<ul>
<li>finally一般用于资源的关闭</li>
<li>else和finally是可选的，可写可不写。</li>
</ul>
<h2 id="3-异常的传递"><a href="#3-异常的传递" class="headerlink" title="3. 异常的传递"></a>3. 异常的传递</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64bccaeb1ddac507ccd13ae6.jpg"
                     
                ></p>
<ul>
<li>异常的传递性告诉我们，如果想要捕获异常的话，并不需要深入到它真正出现异常的那一句话，只要函数之间有调用关系，也就是层级关系，在最顶级的调用这里，依旧可以捕获异常。</li>
</ul>
<h2 id="4-模块"><a href="#4-模块" class="headerlink" title="4. 模块"></a>4. 模块</h2><h3 id="4-1-Python自带模块"><a href="#4-1-Python自带模块" class="headerlink" title="4.1 Python自带模块"></a>4.1 Python自带模块</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64bce2821ddac507cc118d0c.jpg"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64bce2b41ddac507cc1213fd.jpg"
                     
                ></p>
<ul>
<li>中括号在Python里面是可选项，也就是可写可不写。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64bce3021ddac507cc12de58.jpg"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64bce3a61ddac507cc147a39.jpg"
                     
                ></p>
<ul>
<li>用这种方法就只会针对这个模块里面的某一个功能使用。</li>
<li>*号代表的是所有的意思。这样子用的时候就不用写time.sleep(5)了，就直接写sleep(5)就行了</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64bce4f31ddac507cc17b84b.jpg"
                     
                ></p>
<ul>
<li><p>就是给具体的模块和具体的功能改名而已。</p>
</li>
<li><p>模块的导入一般写在开头。</p>
</li>
</ul>
<h3 id="4-2-自定义模块"><a href="#4-2-自定义模块" class="headerlink" title="4.2 自定义模块"></a>4.2 自定义模块</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64bce5b41ddac507cc19b0b7.jpg"
                     
                ></p>
<ul>
<li>就是只需要创建一个Python文件，在里面写好函数，然后要调用的时候import这个文件，就可以直接调用这个文件里面的函数了。</li>
</ul>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64bce6ec1ddac507cc1d102a.jpg"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64bce7cc1ddac507cc1f6e7b.jpg"
                     
                ></p>
<ul>
<li>就是说自定义的模块，本身也是一个py文件，然后我们测试的时候，直接在这个模块里面调用这些函数。但是在其他的py文件如果import这个模块的话，相当于c语言的include了，就是等价于直接把模块的所有内容复制粘贴过来了。这样子测试的时候调用函数，现在也会被执行了。所以Python有一个内置变量__name__，如果你在模块内运行的话，这个变量就等于__main__,如果你在其他文件运行的话，就不等于，这样子测试的函数就不会被执行了，但是我们测试的时候它仍然还是会被执行。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64bce9f11ddac507cc25374c.jpg"
                     
                ></p>
<ul>
<li>最终能import到哪些函数取决于__all__变量。</li>
<li>如果你手动导入，也就是用from的话，那也可以，那就不受__all__的影响了。</li>
</ul>
<h2 id="5-自定义Python包"><a href="#5-自定义Python包" class="headerlink" title="5. 自定义Python包"></a>5. 自定义Python包</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64bd17771ddac507cc9b3b3c.jpg"
                     
                ></p>
<ul>
<li>就是说模块 + <strong>init</strong>.py就等于一个Python的包。</li>
<li><strong>init</strong>.py是一个特殊的文件，只要这个文件存在于文件夹里面，那么这个就是一个Python的包。否则只是一个普通的文件夹。</li>
</ul>
<p>创建Python包：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64bd28db1ddac507ccced2f2.jpg"
                     
                ></p>
<ul>
<li>导入包以后，还有继续选择要导入哪个文件。<strong>包名.文件名</strong></li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64bd2b1f1ddac507ccd7409f.jpg"
                     
                ></p>
<h2 id="6-安装第三方包"><a href="#6-安装第三方包" class="headerlink" title="6. 安装第三方包"></a>6. 安装第三方包</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64bd2c061ddac507ccdabe0d.jpg"
                     
                ></p>
<p>安装第三方包：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64bd2c6d1ddac507ccdc1d15.jpg"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64bd2cb11ddac507ccdd021f.jpg"
                     
                ></p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>可视化图表的开发</title>
    <url>/2023/07/24/%E5%8F%AF%E8%A7%86%E5%8C%96%E5%9B%BE%E8%A1%A8%E7%9A%84%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h1 id="可视化图表的开发"><a href="#可视化图表的开发" class="headerlink" title="可视化图表的开发"></a>可视化图表的开发</h1><h2 id="1-json"><a href="#1-json" class="headerlink" title="1. json"></a>1. json</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64be1c051ddac507ccd41788.jpg"
                     
                ></p>
<p>Python有自己的数据格式，比如字典，列表，c语言，Java<br>也有自己的数据格式。想要相互传递数据，就用json。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64be1c811ddac507ccd5a3ce.jpg"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64be1cc71ddac507ccd67847.jpg"
                     
                ></p>
<ul>
<li>json的格式要么是<strong>字典</strong>，要么是一个<strong>列表里面嵌套的字典</strong>。所以Python和json格式是无缝衔接的。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64be1dc51ddac507ccd956d4.jpg"
                     
                ></p>
<ul>
<li><p>时刻记住json本质上是一个字符串，所以输出json的格式就是str。</p>
</li>
<li><p>用loads方法可以将json格式的数据转换成列表或者字典类型的数据，具体转换成1哪种格式取决于你的json数据。</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64be1fae1ddac507ccdea501.jpg"
                     
                ></p>
<h2 id="2-pyecharts模块"><a href="#2-pyecharts模块" class="headerlink" title="2. pyecharts模块"></a>2. pyecharts模块</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64be1fdf1ddac507ccdf31e7.jpg"
                     
                ></p>
<ul>
<li><p>可以去官网看看<a class="link"   href="https://pyecharts.org/#/en-us/" >pyecharts的官网 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
<li><p>还有官方画廊： <a class="link"   href="https://gallery.pyecharts.org/#/README" >官方画廊 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>      里面有官方示例</p>
</li>
</ul>
<p>pyecharts模块的安装：</p>
<ul>
<li>打开命令行</li>
<li>输入pip install pyecharts</li>
</ul>
<h2 id="3-折线图"><a href="#3-折线图" class="headerlink" title="3. 折线图"></a>3. 折线图</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64be227b1ddac507cce744b1.jpg"
                     
                ></p>
<p>代码：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Line</span><br><span class="line">line = Line()</span><br><span class="line">line.add_xaxis([<span class="string">&quot;中国&quot;</span>,<span class="string">&quot;美国&quot;</span>,<span class="string">&quot;英国&quot;</span>])</span><br><span class="line">line.add_yaxis(<span class="string">&quot;GDP&quot;</span>,[<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span>])</span><br><span class="line">line.render()</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<ul>
<li>运行后会生成一个heml的文件，用浏览器打开以后就得到折线图了。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64be26111ddac507ccf32ec4.jpg"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64be26451ddac507ccf3d62c.jpg"
                     
                ></p>
<ul>
<li>据此继续优化代码：</li>
</ul>
<div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Line</span><br><span class="line"><span class="keyword">from</span> pyecharts.options <span class="keyword">import</span> TitleOpts,LegendOpts,ToolboxOpts,VisualMapOpts</span><br><span class="line">line = Line()</span><br><span class="line">line.add_xaxis([<span class="string">&quot;中国&quot;</span>,<span class="string">&quot;美国&quot;</span>,<span class="string">&quot;英国&quot;</span>])</span><br><span class="line">line.add_yaxis(<span class="string">&quot;GDP&quot;</span>,[<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span>])</span><br><span class="line">line.set_global_opts(</span><br><span class="line">    title_opts=TitleOpts(title=<span class="string">&quot;GDP展示&quot;</span>,pos_left=<span class="string">&quot;center&quot;</span>,pos_bottom=<span class="string">&quot;1%&quot;</span>),</span><br><span class="line">    legend_opts=LegendOpts(is_show=<span class="literal">True</span>),</span><br><span class="line">    toolbox_opts=ToolboxOpts(is_show=<span class="literal">True</span>),</span><br><span class="line">    visualmap_opts=VisualMapOpts(is_show=<span class="literal">True</span>)</span><br><span class="line">)</span><br><span class="line">line.render()</span><br></pre></td></tr></table></figure></div>

<p>效果：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64be39b91ddac507cc3216a8.jpg"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64be39231ddac507cc302243.jpg"
                     
                ></p>
<ul>
<li>更多的全局配置项可以去官网看文档。</li>
</ul>
<h2 id="4-数据处理"><a href="#4-数据处理" class="headerlink" title="4. 数据处理"></a>4. 数据处理</h2><ul>
<li>查看json格式的工具：<a class="link"   href="http://www.ab173.com/" >懒人工具 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，是一个网址，最上面一排有一个：JSON相关。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64bf35091ddac507cc52b87c.jpg"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64bf35861ddac507cc537194.jpg"
                     
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64bf35b61ddac507cc53c802.jpg"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64bf3f091ddac507cc649e2a.jpg"
                     
                ></p>
<h2 id="5-创建折线图"><a href="#5-创建折线图" class="headerlink" title="5. 创建折线图"></a>5. 创建折线图</h2><p>重复上述操作，分别得到美国，日本，印度三个国家的json数据转字典。也就是完成数据处理部分。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64bfcaaa1ddac507cc585091.jpg"
                     
                ></p>
<ul>
<li>因为x轴是共用的，所以x轴数据只需要添加一次就行了。</li>
</ul>
<p>效果图：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64bfcacc1ddac507cc588804.jpg"
                     
                ></p>
<p>设置全局选项：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64bfcbe01ddac507cc5a51a0.jpg"
                     
                ></p>
<ul>
<li><p>可以看到，图里面的y轴数据都显示出来了。这样子很乱，可以设置一下，隐藏起来。就是直接在y轴数据的后面继续配置参数。（记得导入相应的功能）</p>
</li>
<li><p>总结：</p>
</li>
</ul>
<ol>
<li>用open函数读取数据。</li>
<li>删去文件开头和结尾中不符合json格式的语句。</li>
<li>调用json里面的loads方法将json文件转为字典。</li>
<li>用json工具查看json文件的嵌套结构，通过结构获取数据。</li>
<li>生成图表，添加x，y轴数据。并且隐藏y轴的数据，让其不显示。</li>
<li>配置全局选项。</li>
<li>调用render生成图表</li>
<li>关闭文件对象。</li>
</ol>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机的发展和基本组成</title>
    <url>/2023/07/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%8F%91%E5%B1%95%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90/</url>
    <content><![CDATA[<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64c217b51ddac507cce4e9be.jpg"
                     
                ><br>计算机组成原理就是研究硬件之间的关系的。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64c2189e1ddac507cce77f07.jpg"
                     
                ></p>
<ul>
<li>计算机内部传递0,1数据本质上就是用这种高低电平。</li>
<li>CPU或者是内存条上面的引脚，就是用来接收高低电平的。</li>
</ul>
<p><strong>计算机系统 &#x3D; 硬件 + 软件</strong>（软件又可以分为系统软件和应用软件。）</p>
<ul>
<li>机器字长：计算机一次整数运算所能处理的二进制位数。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64c21cc91ddac507ccf071bc.jpg"
                     
                ></p>
]]></content>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>硬件</title>
    <url>/2023/07/27/%E7%A1%AC%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h1><h2 id="1-硬件的整体介绍"><a href="#1-硬件的整体介绍" class="headerlink" title="1. 硬件的整体介绍"></a>1. 硬件的整体介绍</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64c21f451ddac507ccf4e29c.jpg"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64c21fd31ddac507ccf5e154.jpg"
                     
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64c220331ddac507ccf699a7.jpg"
                     
                ><br>缺点：数据输入进来，本来应该要直接放到存储器里面，但是会先放到运算器再放到存储器。同理输出设备本来应该直接从存储器里面拿东西，但是还是要先给运算器，从运算器里面把东西拿出去。</p>
<p>现代计算机结构就是改变这个缺点：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64c2212a1ddac507ccf850d6.jpg"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64c221ae1ddac507ccf93d22.jpg"
                     
                ></p>
<ul>
<li>这里的主机和现实生活中的放在机箱里面的那些主机不同。</li>
<li>主存是主存储器，辅存是硬盘。比如手机的运行内存就是主存。所有下载的APP是放在辅存里面的。只有运行的时候才会把APP的代码数据读取到主存里面去。所以辅存要看做是IO设备。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64c335d71ddac507ccb5aabf.jpg"
                     
                ></p>
<h2 id="2-各个硬件的工作原理"><a href="#2-各个硬件的工作原理" class="headerlink" title="2. 各个硬件的工作原理"></a>2. 各个硬件的工作原理</h2><h3 id="2-1-主存储器"><a href="#2-1-主存储器" class="headerlink" title="2.1 主存储器"></a>2.1 主存储器</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64c336b01ddac507ccb7147c.jpg"
                     
                ></p>
<ul>
<li><p>存储体用来存储数据。</p>
</li>
<li><p>CPU会把想要存放的数据的地址写入MAR里面，主存储器就可以根据MAR里面的地址，从存储体里面拿出CPU想要的数据。</p>
</li>
<li><p>拿出来的数据，写入MDR里面，然后CPU从MDR里面取走数据。</p>
</li>
<li><p>CPU也可以写入数据，写入的数据先放到MDR里面，然后通过控制总线告诉主存储器，这次是写操作。然后主存储器就会根据对应的信息进行写操作了。</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64c339631ddac507ccbb3ce0.jpg"
                     
                ></p>
<ul>
<li>存储字长一般是8的倍数。</li>
<li>字和字节不一样，一个字节是8个比特。但是一个字的大小取决于计算机硬件的设计，可以是8,16,32,64都有可能。</li>
<li>描述字节用B，描述比特用b。比如办宽带，100Mbps是说每秒100Mb,是比特！而用迅雷下载的时候的10MBps，是B，所以并不是运营商骗了你，实际上要100&#x2F;8才是你实际获得的MBps。</li>
</ul>
<h3 id="2-2-运算器"><a href="#2-2-运算器" class="headerlink" title="2.2 运算器"></a>2.2 运算器</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64c33b011ddac507ccbde33e.jpg"
                     
                ></p>
<ul>
<li>ALU是核心。成本也最高。</li>
</ul>
<h3 id="2-3-控制器"><a href="#2-3-控制器" class="headerlink" title="2.3 控制器"></a>2.3 控制器</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64c33b801ddac507ccbed270.jpg"
                     
                ></p>
<ul>
<li>CU是核心。</li>
</ul>
<h3 id="3-计算机的工作过程"><a href="#3-计算机的工作过程" class="headerlink" title="3. 计算机的工作过程"></a>3. 计算机的工作过程</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64c33c1e1ddac507ccbfde3e.jpg"
                     
                ></p>
<ul>
<li>执行指令的时候，CPU会把指令拆解为操作码和地址码。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64c33daa1ddac507ccc29289.jpg"
                     
                ></p>
<ul>
<li><p>括号指的是这个寄存器里面的内容。比如(MAR)指的是MAR寄存器里面的内容。</p>
</li>
<li><p>M指的是主存储器。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64c33e321ddac507ccc3662e.jpg"
                     
                ></p>
</li>
<li><p>指令和数据以同等的地位存于存储器，可以按地址寻访。<strong>指令由操作码和地址码组成。</strong></p>
</li>
<li><p>后面俩步我就省略了。</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64c33f7f1ddac507ccc5c42b.jpg"
                     
                ></p>
<ul>
<li><p>取指令和分析指令的操作都是一样的。只有分析完指令以后，接下来的操作才可能不一样。</p>
</li>
<li><p>取指令的时候，MDR的数据肯定是要传给IR的，而在执行指令的阶段，CU会根据指令的不同去决定MDR的数据内容是放在ACC还是MQ还是X，</p>
</li>
<li><p>所以根据指令执行周期的不同，在不同的阶段，CPU就可以区分出这次从MDR取出来的是数据还是指令。</p>
</li>
<li><p>在程序运行之前，指令和数据都会被提前存储到主存储器里面。</p>
</li>
<li><p>补充：现在的计算机通常把MAR、MDR集成到CPU里面。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机系统的多级层次结构</title>
    <url>/2023/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%9A%E7%BA%A7%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64c36d711ddac507cc1c8c99.jpg"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64c36e2a1ddac507cc1df417.jpg"
                     
                ></p>
<ul>
<li>编译程序，编译一次，就会生成一个.exe的文件，下次就不用重新编译了。解释程序，每次运行都要重新编译。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64c36e2a1ddac507cc1df417.jpg"
                     
                ></p>
]]></content>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机的性能指标</title>
    <url>/2023/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/</url>
    <content><![CDATA[<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64c370991ddac507cc233a1c.jpg"
                     
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64c371181ddac507cc248e11.jpg"
                     
                ></p>
<ul>
<li>1KB就等于1024B。因为2的10次方是1024</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64c372921ddac507cc2760d0.jpg"
                     
                ></p>
<ul>
<li><p>主频就是CPU控制其他硬件的节奏频率。主频不是一定越高越好，还要取决于其他因素。比如CPI。就是说同样执行一个乘法指令，不同CPU的完成方式不一样，导致完成一个指令的周期也不一样。</p>
</li>
<li><p>执行整个程序的耗时也叫做CPU的执行时间。</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64c373681ddac507cc28f4dc.jpg"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64c373e91ddac507cc29e2ca.jpg"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64c374081ddac507cc2a239d.jpg"
                     
                ></p>
<ul>
<li>描述频率的时候G就是10的9次方，而是2的9次方了。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64c3748e1ddac507cc2b2687.jpg"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64c374b21ddac507cc2b6f06.jpg"
                     
                ></p>
]]></content>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统的概念、功能</title>
    <url>/2023/07/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%81%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64c37c371ddac507cc3aca37.jpg"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64c37ca31ddac507cc3b7e35.jpg"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64c37d981ddac507cc3d2a1b.jpg"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64c37de21ddac507cc3db2cf.jpg"
                     
                ></p>
<ul>
<li>操作系统会向上层提供GUI：图形化用户接口。让用户可以使用形象的图像界面进行操作，而不需要使用命令行。</li>
</ul>
<p>命令行又分为俩种：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64c37ed21ddac507cc3f6fe2.jpg"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64c3b7571ddac507cca67616.jpg"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64c3b7be1ddac507cca726a3.jpg"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64c3b7f01ddac507cca77e25.jpg"
                     
                ></p>
]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>存储系统</title>
    <url>/2023/07/28/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h1><h2 id="1-存储系统基本概念"><a href="#1-存储系统基本概念" class="headerlink" title="1. 存储系统基本概念"></a>1. 存储系统基本概念</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64c3ba6c1ddac507ccac03fd.jpg"
                     
                ></p>
<ul>
<li>应用APP都是在辅存里面的，但是辅存的读写速度太慢了。CPU如果直接和辅存去读写数据，会拖累CPU的速度。</li>
<li>所以调用应用的时候会先把程序从辅存掉到主存里面去。</li>
<li>为什么还要增加一个Cache？因为主存的速度还是比CPU慢，所以增加一个Cache缓解CPU和主存之间的速度矛盾。</li>
<li>最上面的寄存器，速度最快，也最少，在CPU里面也就只有几个寄存器。</li>
</ul>
<h2 id="2-存储器的分类"><a href="#2-存储器的分类" class="headerlink" title="2. 存储器的分类"></a>2. 存储器的分类</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64c4867e1ddac507ccd0d4b0.jpg"
                     
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64c486bf1ddac507ccd13103.jpg"
                     
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64c487501ddac507ccd1f81e.jpg"
                     
                ></p>
<ul>
<li><p>顺序存取存储器和直接存取存储器又可以叫做串行访问存储器（读写某个存储单元所需时间和存储单元的物理位置有关。）</p>
</li>
<li><p>这三种存储器都是需要我们先指明一个地址，然后去读取数据。还有一种存储器叫相联存储器（CAM），也就是可以直接按照内容访问的存储器。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64c488501ddac507ccd36700.jpg"
                     
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64c489011ddac507ccd47dee.jpg"
                     
                ></p>
</li>
<li><p>主存是断电丢失存储信息的。你看手机关机以后，本来在主存里面的操作系统等存储信息都没了。重新开机的时候开机动画那么长就是在把操作系统从辅存调到主存。</p>
</li>
<li><p>根据不同的分类方式，可以有很多种分类方法。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64c489981ddac507ccd55508.jpg"
                     
                ></p>
</li>
</ul>
<h2 id="3-主存储器"><a href="#3-主存储器" class="headerlink" title="3. 主存储器"></a>3. 主存储器</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64c48b9d1ddac507ccd851b9.jpg"
                     
                ></p>
<p>怎么根据地址找到我们想要读写的存储单元呢？</p>
<ul>
<li>使用译码器：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64c48da11ddac507ccdb9565.jpg"
                     
                ><br>经过译码器的处理，一个地址信号会被转换成译码器的某一条字选线的高电平输出。</li>
<li>然后通过绿色的那条数据线（位线），把每一位的二进制信息传入MDR的寄存器里面，CPU再通过数据总线从MDR里面取走这一个字长的数据信息。</li>
</ul>
<h2 id="4-SRAM和DRAM"><a href="#4-SRAM和DRAM" class="headerlink" title="4. SRAM和DRAM"></a>4. SRAM和DRAM</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64c52b541ddac507cc061c6c.jpg"
                     
                ></p>
<ul>
<li>DRAM芯片的结构就是上面第三节的那个结构。</li>
<li>DRAM芯片：使用栅极电容存储信息。</li>
<li>SRAM芯片：使用双稳态触发器存储信息。</li>
<li>俩种芯片的核心区别就是存储元不一样。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64c52ccd1ddac507cc0c2355.jpg"
                     
                ></p>
<ul>
<li><p>左边的成本低，集成度高，功耗也低，右边反之。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64c52d3f1ddac507cc0cf001.jpg"
                     
                ></p>
</li>
<li><p>因为DRAM读出数据以后要重写，所以速度更慢。</p>
</li>
<li><p>这两种芯片都属易失性芯片，也就是断电以后信息会丢失。</p>
</li>
<li><p>“刷新”：因为电容里面的电荷会随着时间慢慢流失，这就会导致里面存储的二进制信息出现误差。实际上电容内的电荷只能维持2ms，即使不断电，2ms以后信息也会消失。所以2ms内必须“刷新”一次，给电容充电。而双稳态触发器只要一直供电就不好改变触发器的状态。</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64c5309c1ddac507cc1326b0.jpg"
                     
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64c5311c1ddac507cc141f7f.jpg"
                     
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64c531661ddac507cc14b6d7.jpg"
                     
                ></p>
]]></content>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>通信协议的一些想法</title>
    <url>/2023/07/30/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<ul>
<li>终于顿悟了I2C的协议为什么要求必须配置GPIO引脚为开漏输出模式。（我认为如果是要用硬件I2C的话，还要配置为复用开漏输出模式，复用的意思就是GPIO引脚的控制权交给了片上外设。）为什么是开漏输出呢？因为！开漏输出不能输出高电平，只能输出低电平，所以只能释放SCL或者SDA，注意是释放。而不是拉到高电平。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64c663411ddac507cce89957.jpg"
                     
                ><br>所以I2C的规定就是必须外接上拉电阻和一个VDD，（开漏输出想要输出高电平，必须这样子，并且！STM32F103C8T6是不能输出5V的，所以想要输出5V也得像这样子操作。）所以你释放的时候，GPIO就被上拉到高电平了。一般情况下我们不需要自己去外接上拉电阻和VDD，因为我用到现在，只要这个模块是I2C的通信协议，内部都自己做好了上拉电阻的，至于VDD，我认为就是，模块接了电源以后，这个电源就是VDD，一起用了！</li>
</ul>
<p>并且，GPIO选择的是开漏输出的话，输入也不影响，还是可以输入的。</p>
<ul>
<li>学了这么多的通信协议。我个人感觉，不一定是对的，只是一个猜测：主机和从机都按照规定好的通信协议进行相应的时序操作以后就可以通信，主机如果是单片机的话，那么单片机可以用软件模拟各种时序，实现各种通信协议I2C,SPI,串口通信等等。那么从机比如一块OLED屏幕，它会细分为SPI的和I2C的，也就是说从机只能使用具体的某一个通信协议进行通信，我认为应该是，生产的时候，厂家在内部就通过硬件去让这块屏幕在接收到某个特定的时序的时候就执行对应的操作，也就是厂家把通信协议通过硬件实现，然后做出了这块OLED屏幕。你之所以可以通过I2C去驱动这块屏幕是因为它内部的硬件的构造使得这块屏幕在SCL和SDA这两个引脚收到I2C的对应时序以后，会去解析这个时序，然后执行对应的操作。</li>
</ul>
<p>绕来绕去讲了半天，不知道有没有说清楚。大概就是这么个想法。</p>
]]></content>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>2023电赛G题</title>
    <url>/2023/08/07/2023%E7%94%B5%E8%B5%9BG%E9%A2%98/</url>
    <content><![CDATA[<h1 id="2023年电赛G题（代码以及感受）"><a href="#2023年电赛G题（代码以及感受）" class="headerlink" title="2023年电赛G题（代码以及感受）"></a>2023年电赛G题（代码以及感受）</h1><p>今天是2023年的8月7日，电赛已经结束俩天了。距离去福大的省测还有俩天。</p>
<p>本次电赛有很多和无人机没关系的小模块。我主要负责用stm32f103c8t6完成这些小模块。当然还有一些七七八八的杂活什么的。</p>
<h2 id="1-自制模拟火源"><a href="#1-自制模拟火源" class="headerlink" title="1.自制模拟火源"></a>1.自制模拟火源</h2><p>题目要求是用激光笔照射2s左右可以让这个火源熄灭或者关闭。我的思路就是要在一段时间内一直判断是否被激光笔照射。怎么检测到激光笔的照射呢？利用光敏传感器，值得一提的是我当时调节光敏传感器的灵敏度的时候才发现光敏传感器的指示灯并不灵敏，所以想要真正确保光敏传感器输出电平的跳变，不要依赖指示灯，利用串口调试助手将光敏传感器的输出电平打印出来，才更加保险。</p>
<p>测试光敏传感器输出的高低电平程序：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Serial.h&quot;</span></span></span><br><span class="line"><span class="type">uint8_t</span> flag =<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	OLED_Init();</span><br><span class="line">	</span><br><span class="line">	Serial_Init();</span><br><span class="line">	</span><br><span class="line">  LightSensor_Init();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		flag = LightSensor_Get();</span><br><span class="line">		Serial_SendByte(flag);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>想要照射2s左右熄灭或者点亮LED，需要做到俩点：</p>
<ol>
<li>在这2s内一直判断光敏传感器输出的电平是否满足条件。</li>
<li>记住上一次的状态是熄灭还是点亮才能知道照射俩秒以后是点亮还是熄灭。</li>
</ol>
<p>模拟火源代码：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LightSensor.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    LightSensor_Init();</span><br><span class="line">    LED_Init();</span><br><span class="line">    LED2_OFF();</span><br><span class="line">    <span class="type">uint32_t</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint8_t</span> flag = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (LightSensor_Get() == <span class="number">0</span>)   <span class="comment">// 光敏传感器检测到红外线。</span></span><br><span class="line">        &#123;</span><br><span class="line">					  count++; </span><br><span class="line">            <span class="keyword">if</span> (count &gt;= <span class="number">200</span> )   <span class="comment">// 等待2秒钟</span></span><br><span class="line">            &#123;</span><br><span class="line">               <span class="keyword">if</span> (LightSensor_Get() == <span class="number">0</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                <span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        LED2_ON();   <span class="comment">// LED 灯长亮</span></span><br><span class="line">                        flag = <span class="number">1</span>;</span><br><span class="line">                        count = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        LED2_OFF();  <span class="comment">// LED 灯长灭 </span></span><br><span class="line">                        flag = <span class="number">0</span>;</span><br><span class="line">                        count = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="2-消防车上按键按下启动无人机"><a href="#2-消防车上按键按下启动无人机" class="headerlink" title="2.消防车上按键按下启动无人机"></a>2.消防车上按键按下启动无人机</h2><p>我这里主要负责编写按键发送部分，也就是按键按下，小车上的stm32通过蓝牙向飞控发送一串约定好的信息。飞控接收到这串特定的信息就起飞。</p>
<p>主函数就是简单的几句代码:</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">Key_Init();</span><br><span class="line">KeyNum = Key_GetNum();</span><br><span class="line">    <span class="keyword">if</span>(KeyNum == <span class="number">1</span>)          <span class="comment">//小车上的stm32上面的按键，按下让无人机一键起飞</span></span><br><span class="line">&#123;</span><br><span class="line">    Serial_SendPacket();    <span class="comment">//将一个数组发送出去，这个数组里面存的就是我们约定的信息。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendPacket</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	Serial_SendByte(<span class="number">0xFF</span>);</span><br><span class="line">	Serial_SendArray(Serial_TxPacket, <span class="number">5</span>);</span><br><span class="line">	Serial_SendByte(<span class="number">0xFE</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Key_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line">	GPIO_InitTypeDef GPIOInitStructure;</span><br><span class="line">	GPIOInitStructure.GPIO_Mode=GPIO_Mode_IPU;</span><br><span class="line">	GPIOInitStructure.GPIO_Pin=GPIO_Pin_1|GPIO_Pin_11;</span><br><span class="line">	GPIOInitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOB,&amp;GPIOInitStructure);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>注意的是，需要先用AT指令将两个hc-05蓝牙配置好。</li>
<li>小bug：这个key的初始化函数一定别忘了。我当时忘了，按键没按下去，轻轻晃一晃就会发出信息，我一直以为是误触还是消抖有问题。浪费了一些时间，然后还被海奇嘲笑！现在想想，可能是因为没有初始化，引脚是浮空输入，引脚的高低电平是不确定的，所以外界的一点点扰动就会让引脚高低电平变化。</li>
</ul>
<h2 id="3-OLED-屏幕显示无人机实时坐标、火源坐标、累计航程、航线图"><a href="#3-OLED-屏幕显示无人机实时坐标、火源坐标、累计航程、航线图" class="headerlink" title="3.OLED 屏幕显示无人机实时坐标、火源坐标、累计航程、航线图"></a>3.OLED 屏幕显示无人机实时坐标、火源坐标、累计航程、航线图</h2><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">OLED1_Init();</span><br><span class="line">OLED1_BMP(<span class="number">0</span>);               <span class="comment">//第二块OLED屏幕显示航线图</span></span><br><span class="line"><span class="keyword">if</span> (Serial_GetRxFlag() == <span class="number">1</span> &amp;&amp; Serial_RxPacket[<span class="number">0</span>] == <span class="number">0xF0</span> &amp;&amp; Serial_RxPacket[<span class="number">1</span>] == <span class="number">0x04</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((Serial_RxPacket[<span class="number">0</span>] + Serial_RxPacket[<span class="number">1</span>] + Serial_RxPacket[<span class="number">2</span>] + Serial_RxPacket[<span class="number">3</span>] + Serial_RxPacket[<span class="number">4</span>] + Serial_RxPacket[<span class="number">5</span>] + Serial_RxPacket[<span class="number">6</span>])  %<span class="number">0x100</span> == Serial_RxPacket[<span class="number">7</span>])</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="keyword">if</span>(Serial_RxPacket[<span class="number">2</span>] == <span class="number">0x01</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                data = ((Serial_RxPacket[<span class="number">3</span>] &lt;&lt; <span class="number">8</span>) | Serial_RxPacket[<span class="number">4</span>]);</span><br><span class="line">                </span><br><span class="line">                OLED_ShowNum(<span class="number">1</span>,<span class="number">3</span>,(data / <span class="number">10</span>),<span class="number">2</span>);</span><br><span class="line">                OLED_ShowChar(<span class="number">1</span>,<span class="number">5</span>,<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                OLED_ShowNum(<span class="number">1</span>,<span class="number">6</span>,(data % <span class="number">10</span>),<span class="number">1</span>);</span><br><span class="line">                </span><br><span class="line">                data = ((Serial_RxPacket[<span class="number">5</span>] &lt;&lt; <span class="number">8</span>) | Serial_RxPacket[<span class="number">6</span>]);</span><br><span class="line">                </span><br><span class="line">                OLED_ShowNum(<span class="number">1</span>,<span class="number">10</span>,(data / <span class="number">10</span>),<span class="number">2</span>);</span><br><span class="line">                OLED_ShowChar(<span class="number">1</span>,<span class="number">12</span>,<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                OLED_ShowNum(<span class="number">1</span>,<span class="number">13</span>,(data % <span class="number">10</span>),<span class="number">1</span>);</span><br><span class="line">                </span><br><span class="line">                OLED_ShowString(<span class="number">1</span>,<span class="number">15</span>,<span class="string">&quot;dm&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(Serial_RxPacket[<span class="number">2</span>] == <span class="number">0x02</span> &amp;&amp; flag2 == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                data = ((Serial_RxPacket[<span class="number">3</span>] &lt;&lt; <span class="number">8</span>) | Serial_RxPacket[<span class="number">4</span>]);</span><br><span class="line">                </span><br><span class="line">                OLED_ShowNum(<span class="number">2</span>,<span class="number">3</span>,(data / <span class="number">10</span>),<span class="number">2</span>);</span><br><span class="line">                OLED_ShowChar(<span class="number">2</span>,<span class="number">5</span>,<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                OLED_ShowNum(<span class="number">2</span>,<span class="number">6</span>,(data % <span class="number">10</span>),<span class="number">1</span>);</span><br><span class="line">                </span><br><span class="line">                data = ((Serial_RxPacket[<span class="number">5</span>] &lt;&lt; <span class="number">8</span>) | Serial_RxPacket[<span class="number">6</span>]);</span><br><span class="line">                </span><br><span class="line">                OLED_ShowNum(<span class="number">2</span>,<span class="number">10</span>,(data / <span class="number">10</span>),<span class="number">2</span>);</span><br><span class="line">                OLED_ShowChar(<span class="number">2</span>,<span class="number">12</span>,<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                OLED_ShowNum(<span class="number">2</span>,<span class="number">13</span>,(data % <span class="number">10</span>),<span class="number">1</span>);</span><br><span class="line">                </span><br><span class="line">                OLED_ShowString(<span class="number">2</span>,<span class="number">15</span>,<span class="string">&quot;dm&quot;</span>);</span><br><span class="line">                </span><br><span class="line">                flag2 = <span class="number">0</span>;</span><br><span class="line">                </span><br><span class="line">                flag3 = <span class="number">0</span>;<span class="comment">//stm32给树莓派发消息的标志位</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(Serial_RxPacket[<span class="number">2</span>] == <span class="number">0x03</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                data = ((Serial_RxPacket[<span class="number">3</span>] &lt;&lt; <span class="number">8</span>) | Serial_RxPacket[<span class="number">4</span>]);</span><br><span class="line">                </span><br><span class="line">                OLED_ShowNum(<span class="number">3</span>,<span class="number">5</span>,(data / <span class="number">10</span>),<span class="number">3</span>);</span><br><span class="line">                OLED_ShowChar(<span class="number">3</span>,<span class="number">8</span>,<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                OLED_ShowNum(<span class="number">3</span>,<span class="number">9</span>,(data % <span class="number">10</span>),<span class="number">1</span>);</span><br><span class="line">                OLED_ShowString(<span class="number">3</span>,<span class="number">10</span>,<span class="string">&quot;dm&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>我选择分两块OLED 屏幕显示。一块显示航线图，一块显示无人机实时坐标、火源坐标、累计航程。</p>
<p>在此感谢晓锋哥帮助我解决显示航线图的问题！！！非常感谢！</p>
<h2 id="4-小车上stm32和树莓派通信"><a href="#4-小车上stm32和树莓派通信" class="headerlink" title="4.小车上stm32和树莓派通信"></a>4.小车上stm32和树莓派通信</h2><p>因为我们的小车是用树莓派做的，所以在发挥部分想要完成无人机发消息给小车，让小车前往火源的话，需要飞控给树莓派通信。既然我们小车上已经装了一个stm32了，所以我干脆再配置好usart2，通过ch340接到小车上。最后飞控先和stm32通信，stm32再和树莓派通信。然后小车前进。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(flag == <span class="number">1</span> &amp;&amp; flag3 == <span class="number">0</span>)<span class="comment">//小车上的stm32给树莓派发消息，flag只是让他只发一次，     </span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    USART2_SendByte(<span class="number">0x0f</span>);</span><br><span class="line">    USART2_SendByte(<span class="number">0xf0</span>);</span><br><span class="line">    USART2_SendByte(<span class="number">0x20</span>);</span><br><span class="line">    USART2_SendByte(<span class="number">0x01</span>);</span><br><span class="line">    USART2_SendByte(<span class="number">0x01</span>);</span><br><span class="line">    USART2_SendByte((<span class="number">0x0f</span> + <span class="number">0xf0</span> + <span class="number">0x20</span> + <span class="number">0x01</span> + <span class="number">0x01</span>) % <span class="number">0x100</span>);</span><br><span class="line">    flag = <span class="number">0</span>;</span><br><span class="line">    flag3 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>为了只发一次信息给树莓派，我又增加了flag3，这部分还得配合上面第三部分一起看。整体的意思就是说，飞控发消息给stm32要灭火的信息以后，stm32接收信息以后，把flag3置0，然后stm32就可以发消息给树莓派了，发完信息立马又把flag3置1，这样子就不会再发了。</p>
<h2 id="5-丢灭火包。"><a href="#5-丢灭火包。" class="headerlink" title="5. 丢灭火包。"></a>5. 丢灭火包。</h2><p>因为飞控上的pwm不好调节占空比，所以我们在无人机上再装一个stm32，无人机和这块stm32通信，然后让这块stm32去驱动舵机去丢灭火包。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	Serial_Init();</span><br><span class="line">	PWM_Init();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (Serial_GetRxFlag() == <span class="number">1</span> &amp;&amp; Serial_RxPacket[<span class="number">0</span>] == <span class="number">0x0f</span> &amp;&amp; Serial_RxPacket[<span class="number">1</span>] == <span class="number">0xf0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> ((Serial_RxPacket[<span class="number">0</span>] + Serial_RxPacket[<span class="number">1</span>] + Serial_RxPacket[<span class="number">2</span>]) %<span class="number">0x100</span> == Serial_RxPacket[<span class="number">3</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(Serial_RxPacket[<span class="number">2</span>] == <span class="number">0x10</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					PWM_SetCompare2(<span class="number">500</span>);					</span><br><span class="line">					Delay_s(<span class="number">4</span>);</span><br><span class="line">				    PWM_SetCompare2(<span class="number">0</span>);</span><br><span class="line">					Serial_RxPacket[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">					Serial_RxPacket[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">					Serial_RxPacket[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">					Serial_RxPacket[<span class="number">3</span>] = <span class="number">0</span>;<span class="comment">//为了保险舵机只转一次，说到底是为了省电。</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <tags>
        <tag>2023电赛G题</tag>
      </tags>
  </entry>
  <entry>
    <title>scanf函数的&#92;n问题</title>
    <url>/2023/10/01/scanf%E5%87%BD%E6%95%B0%E7%9A%84-n%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>问题：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int a,b,c;</span><br><span class="line">	scanf(&quot;%d %d\n&quot;,&amp;a,&amp;b);	</span><br><span class="line">	printf(&quot;bingo&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>
<p>这段代码，scanf函数里面的输入最后有一个\n。这段代码运行结果如下：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/651938b2c458853aefa6b17e.jpg"
                     
                ></p>
<p>可以看到，第一次输入1 2以后回车以后并没有结束输入，即使多次回车还是无法结束scanf函数。</p>
<p>除非再次输入1 2然后回车，scanf函数才执行完毕。</p>
<p>这是为什么？</p>
<ol>
<li><p>scanf函数的基本原理：C程序执行scanf时，会从缓冲区读数据，如果缓冲区是空的，就阻塞住，等待你从键盘输入。输入结束后按回车会执行scanf函数，程序会逐个读取缓冲区的数据。注意，这时会将我们最后打的回车也就是\n留在缓冲区（缓冲区只剩下\n）。</p>
</li>
<li><p>加入\n以后。如果在scanf函数的双引号内加入\n并且\n后面还要输入整型即%d，并不会造成影响，因为缓冲区中的\n是字符，并不会被当作%d读入，会被忽略而读取后面的整型数据。示例：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/65193abac458853aefa7b366.jpg"
                     
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/65193a97c458853aefa7ac80.jpg"
                     
                ><br>可以看到此时并不会出现开头所说的那种需要输入俩遍的问题。</p>
</li>
</ol>
<p>而如果后面输入字符型即%c，这时就需要特别注意，因为缓冲区的\n会被当作%c读入，这样就会存在问题。为了解决这一问题，可以用到scanf末尾加\n的方法。</p>
<ol start="3">
<li>前面的都是拓展，这个问题真正的原因是：如果给scanf末尾加上\n，<strong>\n不表示等待换行符，而是读取并放弃连续的空白字符，你输入结束之后按回车不会结束</strong>，无论再输入多少空白字符（空格、制表符、回车）都会被忽略，要等再接收到一个非空白字符的输入后scanf语句才结束。但需要注意的是，最后输入的那个非（空格、制表符、回车）的东西是不会被这个scanf读进来的，而是留在缓冲区中。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/65193d1ec458853aefa8429a.jpg"
                     
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/65193d3ac458853aefa84e82.jpg"
                     
                ></p>
<p>因此你看，还是原来的代码，我输入1 2以后怎么回车都没用。然后只有当我再次输入一个非空白字符，也就是那个3以后，我再回车，scanf函数就读取缓冲区结束了。并且也可以看到最后输入的3并没有被scanf函数读取。</p>
]]></content>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
</search>
